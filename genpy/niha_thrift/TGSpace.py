#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []
from Wrapper.TGraphWrapper import Neo4jGraph
from Wrapper.TNodeWrapper import Neo4jNode
from Wrapper.TRelationWrapper import Neo4jRelation

class Iface(object):
    def __init__(self):
        self.node = Neo4jNode()
        self.relation = Neo4jRelation()
        self.graph = Neo4jGraph()

    def GetFrequency(self):
        pass

    def GetFrequencyByUser(self, user):
        """
        Parameters:
         - user
        """
        pass

    def SignIn(self, user, Password):
        """
        Parameters:
         - user
         - Password
        """
        pass

    def SignOut(self, user):
        """
        Parameters:
         - user
        """
        pass

    def Ping(self):
        print("ping")

    def CreateGraph(self, graph):
        """
        Parameters:
         - graph
        """
        self.graph.set_graph(graph)
        res= self.graph.create_graph()
        return res
    def UpdateGraph(self, graph):
        """
        Parameters:
         - graph
        """
        pass

    def DeleteGraph(self, criteria):
        """
        Parameters:
         - criteria
        """
        pass

    def RetrieveGraphs(self, query):
        """
        Parameters:
         - query
        """
       # print(query)
        res= self.graph.retrieve_by_query(query)
        #print(type(res))
        #print(res)
        return res
    def RetrieveGraphByGraphID(self, graphid, limit):
        """
        Parameters:
         - graphid
         - limit
        """
        pass
    def RetrieveGraphsByAoKID(self, id, limit):
        """
        Parameters:
         - id
         - limit
        """
        pass

    def RetrieveGraphsByAllSubjectSpecializationOf(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetrieveGraphsByAnySubjectSpecializationOf(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        res= self.graph.retrieve_by_AnySubjectSpecializationOf(criteria,limit)
        #print(type(res))
        return res
    def RetrieveGraphsByAllNameLabels(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetrieveGraphsByAnyNameLabels(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        res= self.graph.retrieve_by_AnyNameLabels(criteria,limit)
       # print(type(res))
        return res
    def RetrieveGraphsByTypes(self, types, limit):
        """
        Parameters:
         - types
         - limit
        """
        res= self.graph.retrieve_by_Types(types,limit)
        #print(type(res))
        return res
    def RetrieveGraphsByTypeAndName(self, type, name, limit):
        """
        Parameters:
         - type
         - name
         - limit
        """
        pass

    def GetGraphByTypeAndSpecialization(self, type, specialization_criteria, limit):
        """
        Parameters:
         - type
         - specialization_criteria
         - limit
        """
        res= self.graph.retrieve_by_TypeAndSpecialization(type, specialization_criteria,limit)
        #print(type(res))
        return res
    def RetrieveGraphsCreatedByNiHA(self, limit):
        """
        Parameters:
         - limit
        """
        pass

    def RetrieveGraphsCreatedByNiHAWithUser(self, when_this_user_was_signedin, limit):
        """
        Parameters:
         - when_this_user_was_signedin
         - limit
        """
        pass

    def RetrieveGraphsCreatedByNiHAWithCriteria(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetriveGraphsUniqueListOfAllSubjectSpecializationLabels(self, limit):
        """
        Parameters:
         - limit
        """
        pass

    def CreateRelation(self, relations):
        """
        Parameters:
         - relations
        """
        self.relation.set_relation(relations)
        res=self.relation.create_relation()
        #print(type(res))
        return res

    def CreateRelationWithNodes(self, source_node, target_node):
        """
        Parameters:
         - source_node
         - target_node
        """
        pass

    def UpdateRelation(self, relation):
        """
        Parameters:
         - relation
        """
        pass

    def DeleteRelation(self, criteria):
        """
        Parameters:
         - criteria
        """
        pass

    def RetrieveRelationByNeo4jId(self, id, limit):
        """
        Parameters:
         - id
         - limit
        """
        pass

    def RetrieveRelations(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetrieveRelationsByGraphID(self, graphid, limit):
        """
        Parameters:
         - graphid
         - limit
        """
        res= self.relation.retrieve_relation_by_Graphid(graphid, limit)
        #print(type(res[0]))
        return res

    def RetrieveRelationsByAoKID(self, id, limit):
        """
        Parameters:
         - id
         - limit
        """
        pass

    def RetrieveRelationsBySpecializationOf(self, subject_specialization, limit):
        """
        Parameters:
         - subject_specialization
         - limit
        """
        pass

    def RetrieveRelationsNameLabels(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        res= self.relation.retrieve_relation_by_NameLabels(criteria,limit)
        #print(type(res))
        return res

    def RetrieveRelationsTruthValue(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetrieveRelationsByDateTime(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetrieveRelationsByAge(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetrieveRelationsAttentionLevel(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetrieveRelationsScratchPad(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetrieveRelationsByUser(self, userid, limit):
        """
        Parameters:
         - userid
         - limit
        """
        pass

    def RetrieveRelationsCreateByUser(self, userid, limit):
        """
        Parameters:
         - userid
         - limit
        """
        pass

    def RetrieveRelationsCreatedByNiHA(self, limit):
        """
        Parameters:
         - limit
        """
        pass

    def RetrieveRelationsCreatedByNiHAWithUser(self, when_this_user_was_signedin, limit):
        """
        Parameters:
         - when_this_user_was_signedin
         - limit
        """
        pass

    def RetrieveRelationsCreatedByNiHAWithCriteria(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetrieveRelationsUniqueListOfAllSpecializationLabels(self, limit):
        """
        Parameters:
         - limit
        """
        res= self.relation.retrieve_relation_by_UniqueListOfAllSpecializationLabels(limit)
        #print(type(res))
        return res
    def CreateNodes(self, node):
        """
        Parameters:
         - node
        """
        self.node.set_node(node)
        return self.node.create_node()

    def RetrieveByNeo4jId(self, id):
        """
        Parameters:
         - id
        """
        pass

    def RetrieveNodes(self, query):
        """
        Parameters:
         - query
        """
        return self.node.retrieve_nodes(query)

    def RetrieveNodesByGraphID(self, graphid, limit):
        """
        Parameters:
         - graphid
         - limit
        """
        pass

    def RetrieveNodesByAoKID(self, id, limit):
        """
        Parameters:
         - id
         - limit
        """
        pass

    def RetrieveNodesByAllSubjectSpecializationOf(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetrieveNodesByAnySubjectSpecializationOf(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        return self.node.retrieve_by_AnySubjectSpecializationOf(criteria,limit)

    def RetrieveNodesByAnyNameLabels(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        return self.node.retrieve_by_AnyNameLabels(criteria,limit)

    def RetrieveNodesByAllNameLabels(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetrieveNodesTruthValue(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetrieveNodesByEvaluation(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetrieveNodesByDateTime(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetrieveNodesByAge(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetrieveNodesAttentionLevel(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetrieveNodesByScratchPad(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetrieveNodesByUser(self, userid, limit):
        """
        Parameters:
         - userid
         - limit
        """
        pass

    def RetrieveNodesCreateByUser(self, userid, limit):
        """
        Parameters:
         - userid
         - limit
        """
        pass

    def RetrieveNodesCreatedByNiHA(self, limit):
        """
        Parameters:
         - limit
        """
        pass

    def RetrieveNodesCreatedByNiHAWithUser(self, when_this_user_was_signedin, limit):
        """
        Parameters:
         - when_this_user_was_signedin
         - limit
        """
        pass

    def RetrieveNodesCreatedByNiHAWithCriteria(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        pass

    def RetriveNodesUniqueListOfAllSpecializationLabels(self, limit):
        """
        Parameters:
         - limit
        """
        return self.node.retrieve_by_UniqueListOfAllSpecializationLabels(limit)

    def UpdateNode(self, node):
        """
        Parameters:
         - node
        """
        pass

    def DeleteNode(self, criteria):
        """
        Parameters:
         - criteria
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def GetFrequency(self):
        self.send_GetFrequency()
        return self.recv_GetFrequency()

    def send_GetFrequency(self):
        self._oprot.writeMessageBegin('GetFrequency', TMessageType.CALL, self._seqid)
        args = GetFrequency_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetFrequency(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetFrequency_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetFrequency failed: unknown result")

    def GetFrequencyByUser(self, user):
        """
        Parameters:
         - user
        """
        self.send_GetFrequencyByUser(user)
        return self.recv_GetFrequencyByUser()

    def send_GetFrequencyByUser(self, user):
        self._oprot.writeMessageBegin('GetFrequencyByUser', TMessageType.CALL, self._seqid)
        args = GetFrequencyByUser_args()
        args.user = user
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetFrequencyByUser(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetFrequencyByUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetFrequencyByUser failed: unknown result")

    def SignIn(self, user, Password):
        """
        Parameters:
         - user
         - Password
        """
        self.send_SignIn(user, Password)
        return self.recv_SignIn()

    def send_SignIn(self, user, Password):
        self._oprot.writeMessageBegin('SignIn', TMessageType.CALL, self._seqid)
        args = SignIn_args()
        args.user = user
        args.Password = Password
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SignIn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SignIn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SignIn failed: unknown result")

    def SignOut(self, user):
        """
        Parameters:
         - user
        """
        self.send_SignOut(user)
        return self.recv_SignOut()

    def send_SignOut(self, user):
        self._oprot.writeMessageBegin('SignOut', TMessageType.CALL, self._seqid)
        args = SignOut_args()
        args.user = user
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_SignOut(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = SignOut_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "SignOut failed: unknown result")

    def Ping(self):
        self.send_Ping()
        self.recv_Ping()

    def send_Ping(self):
        self._oprot.writeMessageBegin('Ping', TMessageType.CALL, self._seqid)
        args = Ping_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_Ping(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = Ping_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def CreateGraph(self, graph):
        """
        Parameters:
         - graph
        """
        self.send_CreateGraph(graph)
        return self.recv_CreateGraph()

    def send_CreateGraph(self, graph):
        self._oprot.writeMessageBegin('CreateGraph', TMessageType.CALL, self._seqid)
        args = CreateGraph_args()
        args.graph = graph
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CreateGraph(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CreateGraph_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CreateGraph failed: unknown result")

    def UpdateGraph(self, graph):
        """
        Parameters:
         - graph
        """
        self.send_UpdateGraph(graph)
        return self.recv_UpdateGraph()

    def send_UpdateGraph(self, graph):
        self._oprot.writeMessageBegin('UpdateGraph', TMessageType.CALL, self._seqid)
        args = UpdateGraph_args()
        args.graph = graph
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_UpdateGraph(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = UpdateGraph_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "UpdateGraph failed: unknown result")

    def DeleteGraph(self, criteria):
        """
        Parameters:
         - criteria
        """
        self.send_DeleteGraph(criteria)
        return self.recv_DeleteGraph()

    def send_DeleteGraph(self, criteria):
        self._oprot.writeMessageBegin('DeleteGraph', TMessageType.CALL, self._seqid)
        args = DeleteGraph_args()
        args.criteria = criteria
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_DeleteGraph(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = DeleteGraph_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "DeleteGraph failed: unknown result")

    def RetrieveGraphs(self, query):
        """
        Parameters:
         - query
        """
        self.send_RetrieveGraphs(query)
        return self.recv_RetrieveGraphs()

    def send_RetrieveGraphs(self, query):
        self._oprot.writeMessageBegin('RetrieveGraphs', TMessageType.CALL, self._seqid)
        args = RetrieveGraphs_args()
        args.query = query
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveGraphs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveGraphs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveGraphs failed: unknown result")

    def RetrieveGraphByGraphID(self, graphid, limit):
        """
        Parameters:
         - graphid
         - limit
        """
        self.send_RetrieveGraphByGraphID(graphid, limit)
        return self.recv_RetrieveGraphByGraphID()

    def send_RetrieveGraphByGraphID(self, graphid, limit):
        self._oprot.writeMessageBegin('RetrieveGraphByGraphID', TMessageType.CALL, self._seqid)
        args = RetrieveGraphByGraphID_args()
        args.graphid = graphid
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveGraphByGraphID(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveGraphByGraphID_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveGraphByGraphID failed: unknown result")

    def RetrieveGraphsByAoKID(self, id, limit):
        """
        Parameters:
         - id
         - limit
        """
        self.send_RetrieveGraphsByAoKID(id, limit)
        return self.recv_RetrieveGraphsByAoKID()

    def send_RetrieveGraphsByAoKID(self, id, limit):
        self._oprot.writeMessageBegin('RetrieveGraphsByAoKID', TMessageType.CALL, self._seqid)
        args = RetrieveGraphsByAoKID_args()
        args.id = id
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveGraphsByAoKID(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveGraphsByAoKID_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveGraphsByAoKID failed: unknown result")

    def RetrieveGraphsByAllSubjectSpecializationOf(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveGraphsByAllSubjectSpecializationOf(criteria, limit)
        return self.recv_RetrieveGraphsByAllSubjectSpecializationOf()

    def send_RetrieveGraphsByAllSubjectSpecializationOf(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveGraphsByAllSubjectSpecializationOf', TMessageType.CALL, self._seqid)
        args = RetrieveGraphsByAllSubjectSpecializationOf_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveGraphsByAllSubjectSpecializationOf(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveGraphsByAllSubjectSpecializationOf_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveGraphsByAllSubjectSpecializationOf failed: unknown result")

    def RetrieveGraphsByAnySubjectSpecializationOf(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveGraphsByAnySubjectSpecializationOf(criteria, limit)
        return self.recv_RetrieveGraphsByAnySubjectSpecializationOf()

    def send_RetrieveGraphsByAnySubjectSpecializationOf(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveGraphsByAnySubjectSpecializationOf', TMessageType.CALL, self._seqid)
        args = RetrieveGraphsByAnySubjectSpecializationOf_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveGraphsByAnySubjectSpecializationOf(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveGraphsByAnySubjectSpecializationOf_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveGraphsByAnySubjectSpecializationOf failed: unknown result")

    def RetrieveGraphsByAllNameLabels(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveGraphsByAllNameLabels(criteria, limit)
        return self.recv_RetrieveGraphsByAllNameLabels()

    def send_RetrieveGraphsByAllNameLabels(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveGraphsByAllNameLabels', TMessageType.CALL, self._seqid)
        args = RetrieveGraphsByAllNameLabels_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveGraphsByAllNameLabels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveGraphsByAllNameLabels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveGraphsByAllNameLabels failed: unknown result")

    def RetrieveGraphsByAnyNameLabels(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveGraphsByAnyNameLabels(criteria, limit)
        return self.recv_RetrieveGraphsByAnyNameLabels()

    def send_RetrieveGraphsByAnyNameLabels(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveGraphsByAnyNameLabels', TMessageType.CALL, self._seqid)
        args = RetrieveGraphsByAnyNameLabels_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveGraphsByAnyNameLabels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveGraphsByAnyNameLabels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveGraphsByAnyNameLabels failed: unknown result")

    def RetrieveGraphsByTypes(self, types, limit):
        """
        Parameters:
         - types
         - limit
        """
        self.send_RetrieveGraphsByTypes(types, limit)
        return self.recv_RetrieveGraphsByTypes()

    def send_RetrieveGraphsByTypes(self, types, limit):
        self._oprot.writeMessageBegin('RetrieveGraphsByTypes', TMessageType.CALL, self._seqid)
        args = RetrieveGraphsByTypes_args()
        args.types = types
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveGraphsByTypes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveGraphsByTypes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveGraphsByTypes failed: unknown result")

    def RetrieveGraphsByTypeAndName(self, type, name, limit):
        """
        Parameters:
         - type
         - name
         - limit
        """
        self.send_RetrieveGraphsByTypeAndName(type, name, limit)
        return self.recv_RetrieveGraphsByTypeAndName()

    def send_RetrieveGraphsByTypeAndName(self, type, name, limit):
        self._oprot.writeMessageBegin('RetrieveGraphsByTypeAndName', TMessageType.CALL, self._seqid)
        args = RetrieveGraphsByTypeAndName_args()
        args.type = type
        args.name = name
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveGraphsByTypeAndName(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveGraphsByTypeAndName_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveGraphsByTypeAndName failed: unknown result")

    def GetGraphByTypeAndSpecialization(self, type, specialization_criteria, limit):
        """
        Parameters:
         - type
         - specialization_criteria
         - limit
        """
        self.send_GetGraphByTypeAndSpecialization(type, specialization_criteria, limit)
        return self.recv_GetGraphByTypeAndSpecialization()

    def send_GetGraphByTypeAndSpecialization(self, type, specialization_criteria, limit):
        self._oprot.writeMessageBegin('GetGraphByTypeAndSpecialization', TMessageType.CALL, self._seqid)
        args = GetGraphByTypeAndSpecialization_args()
        args.type = type
        args.specialization_criteria = specialization_criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetGraphByTypeAndSpecialization(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetGraphByTypeAndSpecialization_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetGraphByTypeAndSpecialization failed: unknown result")

    def RetrieveGraphsCreatedByNiHA(self, limit):
        """
        Parameters:
         - limit
        """
        self.send_RetrieveGraphsCreatedByNiHA(limit)
        return self.recv_RetrieveGraphsCreatedByNiHA()

    def send_RetrieveGraphsCreatedByNiHA(self, limit):
        self._oprot.writeMessageBegin('RetrieveGraphsCreatedByNiHA', TMessageType.CALL, self._seqid)
        args = RetrieveGraphsCreatedByNiHA_args()
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveGraphsCreatedByNiHA(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveGraphsCreatedByNiHA_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveGraphsCreatedByNiHA failed: unknown result")

    def RetrieveGraphsCreatedByNiHAWithUser(self, when_this_user_was_signedin, limit):
        """
        Parameters:
         - when_this_user_was_signedin
         - limit
        """
        self.send_RetrieveGraphsCreatedByNiHAWithUser(when_this_user_was_signedin, limit)
        return self.recv_RetrieveGraphsCreatedByNiHAWithUser()

    def send_RetrieveGraphsCreatedByNiHAWithUser(self, when_this_user_was_signedin, limit):
        self._oprot.writeMessageBegin('RetrieveGraphsCreatedByNiHAWithUser', TMessageType.CALL, self._seqid)
        args = RetrieveGraphsCreatedByNiHAWithUser_args()
        args.when_this_user_was_signedin = when_this_user_was_signedin
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveGraphsCreatedByNiHAWithUser(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveGraphsCreatedByNiHAWithUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveGraphsCreatedByNiHAWithUser failed: unknown result")

    def RetrieveGraphsCreatedByNiHAWithCriteria(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveGraphsCreatedByNiHAWithCriteria(criteria, limit)
        return self.recv_RetrieveGraphsCreatedByNiHAWithCriteria()

    def send_RetrieveGraphsCreatedByNiHAWithCriteria(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveGraphsCreatedByNiHAWithCriteria', TMessageType.CALL, self._seqid)
        args = RetrieveGraphsCreatedByNiHAWithCriteria_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveGraphsCreatedByNiHAWithCriteria(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveGraphsCreatedByNiHAWithCriteria_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveGraphsCreatedByNiHAWithCriteria failed: unknown result")

    def RetriveGraphsUniqueListOfAllSubjectSpecializationLabels(self, limit):
        """
        Parameters:
         - limit
        """
        self.send_RetriveGraphsUniqueListOfAllSubjectSpecializationLabels(limit)
        return self.recv_RetriveGraphsUniqueListOfAllSubjectSpecializationLabels()

    def send_RetriveGraphsUniqueListOfAllSubjectSpecializationLabels(self, limit):
        self._oprot.writeMessageBegin('RetriveGraphsUniqueListOfAllSubjectSpecializationLabels', TMessageType.CALL, self._seqid)
        args = RetriveGraphsUniqueListOfAllSubjectSpecializationLabels_args()
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetriveGraphsUniqueListOfAllSubjectSpecializationLabels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetriveGraphsUniqueListOfAllSubjectSpecializationLabels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetriveGraphsUniqueListOfAllSubjectSpecializationLabels failed: unknown result")

    def CreateRelation(self, relations):
        """
        Parameters:
         - relations
        """
        self.send_CreateRelation(relations)
        return self.recv_CreateRelation()

    def send_CreateRelation(self, relations):
        self._oprot.writeMessageBegin('CreateRelation', TMessageType.CALL, self._seqid)
        args = CreateRelation_args()
        args.relations = relations
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CreateRelation(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CreateRelation_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CreateRelation failed: unknown result")

    def CreateRelationWithNodes(self, source_node, target_node):
        """
        Parameters:
         - source_node
         - target_node
        """
        self.send_CreateRelationWithNodes(source_node, target_node)
        return self.recv_CreateRelationWithNodes()

    def send_CreateRelationWithNodes(self, source_node, target_node):
        self._oprot.writeMessageBegin('CreateRelationWithNodes', TMessageType.CALL, self._seqid)
        args = CreateRelationWithNodes_args()
        args.source_node = source_node
        args.target_node = target_node
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CreateRelationWithNodes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CreateRelationWithNodes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CreateRelationWithNodes failed: unknown result")

    def UpdateRelation(self, relation):
        """
        Parameters:
         - relation
        """
        self.send_UpdateRelation(relation)
        return self.recv_UpdateRelation()

    def send_UpdateRelation(self, relation):
        self._oprot.writeMessageBegin('UpdateRelation', TMessageType.CALL, self._seqid)
        args = UpdateRelation_args()
        args.relation = relation
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_UpdateRelation(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = UpdateRelation_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "UpdateRelation failed: unknown result")

    def DeleteRelation(self, criteria):
        """
        Parameters:
         - criteria
        """
        self.send_DeleteRelation(criteria)
        return self.recv_DeleteRelation()

    def send_DeleteRelation(self, criteria):
        self._oprot.writeMessageBegin('DeleteRelation', TMessageType.CALL, self._seqid)
        args = DeleteRelation_args()
        args.criteria = criteria
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_DeleteRelation(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = DeleteRelation_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "DeleteRelation failed: unknown result")

    def RetrieveRelationByNeo4jId(self, id, limit):
        """
        Parameters:
         - id
         - limit
        """
        self.send_RetrieveRelationByNeo4jId(id, limit)
        return self.recv_RetrieveRelationByNeo4jId()

    def send_RetrieveRelationByNeo4jId(self, id, limit):
        self._oprot.writeMessageBegin('RetrieveRelationByNeo4jId', TMessageType.CALL, self._seqid)
        args = RetrieveRelationByNeo4jId_args()
        args.id = id
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveRelationByNeo4jId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveRelationByNeo4jId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveRelationByNeo4jId failed: unknown result")

    def RetrieveRelations(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveRelations(criteria, limit)
        return self.recv_RetrieveRelations()

    def send_RetrieveRelations(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveRelations', TMessageType.CALL, self._seqid)
        args = RetrieveRelations_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveRelations(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveRelations_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveRelations failed: unknown result")

    def RetrieveRelationsByGraphID(self, graphid, limit):
        """
        Parameters:
         - graphid
         - limit
        """
        self.send_RetrieveRelationsByGraphID(graphid, limit)
        return self.recv_RetrieveRelationsByGraphID()

    def send_RetrieveRelationsByGraphID(self, graphid, limit):
        self._oprot.writeMessageBegin('RetrieveRelationsByGraphID', TMessageType.CALL, self._seqid)
        args = RetrieveRelationsByGraphID_args()
        args.graphid = graphid
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveRelationsByGraphID(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveRelationsByGraphID_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveRelationsByGraphID failed: unknown result")

    def RetrieveRelationsByAoKID(self, id, limit):
        """
        Parameters:
         - id
         - limit
        """
        self.send_RetrieveRelationsByAoKID(id, limit)
        return self.recv_RetrieveRelationsByAoKID()

    def send_RetrieveRelationsByAoKID(self, id, limit):
        self._oprot.writeMessageBegin('RetrieveRelationsByAoKID', TMessageType.CALL, self._seqid)
        args = RetrieveRelationsByAoKID_args()
        args.id = id
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveRelationsByAoKID(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveRelationsByAoKID_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveRelationsByAoKID failed: unknown result")

    def RetrieveRelationsBySpecializationOf(self, subject_specialization, limit):
        """
        Parameters:
         - subject_specialization
         - limit
        """
        self.send_RetrieveRelationsBySpecializationOf(subject_specialization, limit)
        return self.recv_RetrieveRelationsBySpecializationOf()

    def send_RetrieveRelationsBySpecializationOf(self, subject_specialization, limit):
        self._oprot.writeMessageBegin('RetrieveRelationsBySpecializationOf', TMessageType.CALL, self._seqid)
        args = RetrieveRelationsBySpecializationOf_args()
        args.subject_specialization = subject_specialization
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveRelationsBySpecializationOf(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveRelationsBySpecializationOf_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveRelationsBySpecializationOf failed: unknown result")

    def RetrieveRelationsNameLabels(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveRelationsNameLabels(criteria, limit)
        return self.recv_RetrieveRelationsNameLabels()

    def send_RetrieveRelationsNameLabels(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveRelationsNameLabels', TMessageType.CALL, self._seqid)
        args = RetrieveRelationsNameLabels_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveRelationsNameLabels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveRelationsNameLabels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveRelationsNameLabels failed: unknown result")

    def RetrieveRelationsTruthValue(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveRelationsTruthValue(criteria, limit)
        return self.recv_RetrieveRelationsTruthValue()

    def send_RetrieveRelationsTruthValue(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveRelationsTruthValue', TMessageType.CALL, self._seqid)
        args = RetrieveRelationsTruthValue_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveRelationsTruthValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveRelationsTruthValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveRelationsTruthValue failed: unknown result")

    def RetrieveRelationsByDateTime(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveRelationsByDateTime(criteria, limit)
        return self.recv_RetrieveRelationsByDateTime()

    def send_RetrieveRelationsByDateTime(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveRelationsByDateTime', TMessageType.CALL, self._seqid)
        args = RetrieveRelationsByDateTime_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveRelationsByDateTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveRelationsByDateTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveRelationsByDateTime failed: unknown result")

    def RetrieveRelationsByAge(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveRelationsByAge(criteria, limit)
        return self.recv_RetrieveRelationsByAge()

    def send_RetrieveRelationsByAge(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveRelationsByAge', TMessageType.CALL, self._seqid)
        args = RetrieveRelationsByAge_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveRelationsByAge(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveRelationsByAge_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveRelationsByAge failed: unknown result")

    def RetrieveRelationsAttentionLevel(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveRelationsAttentionLevel(criteria, limit)
        return self.recv_RetrieveRelationsAttentionLevel()

    def send_RetrieveRelationsAttentionLevel(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveRelationsAttentionLevel', TMessageType.CALL, self._seqid)
        args = RetrieveRelationsAttentionLevel_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveRelationsAttentionLevel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveRelationsAttentionLevel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveRelationsAttentionLevel failed: unknown result")

    def RetrieveRelationsScratchPad(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveRelationsScratchPad(criteria, limit)
        return self.recv_RetrieveRelationsScratchPad()

    def send_RetrieveRelationsScratchPad(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveRelationsScratchPad', TMessageType.CALL, self._seqid)
        args = RetrieveRelationsScratchPad_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveRelationsScratchPad(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveRelationsScratchPad_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveRelationsScratchPad failed: unknown result")

    def RetrieveRelationsByUser(self, userid, limit):
        """
        Parameters:
         - userid
         - limit
        """
        self.send_RetrieveRelationsByUser(userid, limit)
        return self.recv_RetrieveRelationsByUser()

    def send_RetrieveRelationsByUser(self, userid, limit):
        self._oprot.writeMessageBegin('RetrieveRelationsByUser', TMessageType.CALL, self._seqid)
        args = RetrieveRelationsByUser_args()
        args.userid = userid
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveRelationsByUser(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveRelationsByUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveRelationsByUser failed: unknown result")

    def RetrieveRelationsCreateByUser(self, userid, limit):
        """
        Parameters:
         - userid
         - limit
        """
        self.send_RetrieveRelationsCreateByUser(userid, limit)
        return self.recv_RetrieveRelationsCreateByUser()

    def send_RetrieveRelationsCreateByUser(self, userid, limit):
        self._oprot.writeMessageBegin('RetrieveRelationsCreateByUser', TMessageType.CALL, self._seqid)
        args = RetrieveRelationsCreateByUser_args()
        args.userid = userid
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveRelationsCreateByUser(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveRelationsCreateByUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveRelationsCreateByUser failed: unknown result")

    def RetrieveRelationsCreatedByNiHA(self, limit):
        """
        Parameters:
         - limit
        """
        self.send_RetrieveRelationsCreatedByNiHA(limit)
        return self.recv_RetrieveRelationsCreatedByNiHA()

    def send_RetrieveRelationsCreatedByNiHA(self, limit):
        self._oprot.writeMessageBegin('RetrieveRelationsCreatedByNiHA', TMessageType.CALL, self._seqid)
        args = RetrieveRelationsCreatedByNiHA_args()
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveRelationsCreatedByNiHA(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveRelationsCreatedByNiHA_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveRelationsCreatedByNiHA failed: unknown result")

    def RetrieveRelationsCreatedByNiHAWithUser(self, when_this_user_was_signedin, limit):
        """
        Parameters:
         - when_this_user_was_signedin
         - limit
        """
        self.send_RetrieveRelationsCreatedByNiHAWithUser(when_this_user_was_signedin, limit)
        return self.recv_RetrieveRelationsCreatedByNiHAWithUser()

    def send_RetrieveRelationsCreatedByNiHAWithUser(self, when_this_user_was_signedin, limit):
        self._oprot.writeMessageBegin('RetrieveRelationsCreatedByNiHAWithUser', TMessageType.CALL, self._seqid)
        args = RetrieveRelationsCreatedByNiHAWithUser_args()
        args.when_this_user_was_signedin = when_this_user_was_signedin
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveRelationsCreatedByNiHAWithUser(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveRelationsCreatedByNiHAWithUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveRelationsCreatedByNiHAWithUser failed: unknown result")

    def RetrieveRelationsCreatedByNiHAWithCriteria(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveRelationsCreatedByNiHAWithCriteria(criteria, limit)
        return self.recv_RetrieveRelationsCreatedByNiHAWithCriteria()

    def send_RetrieveRelationsCreatedByNiHAWithCriteria(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveRelationsCreatedByNiHAWithCriteria', TMessageType.CALL, self._seqid)
        args = RetrieveRelationsCreatedByNiHAWithCriteria_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveRelationsCreatedByNiHAWithCriteria(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveRelationsCreatedByNiHAWithCriteria_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveRelationsCreatedByNiHAWithCriteria failed: unknown result")

    def RetrieveRelationsUniqueListOfAllSpecializationLabels(self, limit):
        """
        Parameters:
         - limit
        """
        self.send_RetrieveRelationsUniqueListOfAllSpecializationLabels(limit)
        return self.recv_RetrieveRelationsUniqueListOfAllSpecializationLabels()

    def send_RetrieveRelationsUniqueListOfAllSpecializationLabels(self, limit):
        self._oprot.writeMessageBegin('RetrieveRelationsUniqueListOfAllSpecializationLabels', TMessageType.CALL, self._seqid)
        args = RetrieveRelationsUniqueListOfAllSpecializationLabels_args()
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveRelationsUniqueListOfAllSpecializationLabels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveRelationsUniqueListOfAllSpecializationLabels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveRelationsUniqueListOfAllSpecializationLabels failed: unknown result")

    def CreateNodes(self, node):
        """
        Parameters:
         - node
        """
        self.send_CreateNodes(node)
        return self.recv_CreateNodes()

    def send_CreateNodes(self, node):
        self._oprot.writeMessageBegin('CreateNodes', TMessageType.CALL, self._seqid)
        args = CreateNodes_args()
        args.node = node
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CreateNodes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CreateNodes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CreateNodes failed: unknown result")

    def RetrieveByNeo4jId(self, id):
        """
        Parameters:
         - id
        """
        self.send_RetrieveByNeo4jId(id)
        return self.recv_RetrieveByNeo4jId()

    def send_RetrieveByNeo4jId(self, id):
        self._oprot.writeMessageBegin('RetrieveByNeo4jId', TMessageType.CALL, self._seqid)
        args = RetrieveByNeo4jId_args()
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveByNeo4jId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveByNeo4jId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveByNeo4jId failed: unknown result")

    def RetrieveNodes(self, query):
        """
        Parameters:
         - query
        """
        self.send_RetrieveNodes(query)
        return self.recv_RetrieveNodes()

    def send_RetrieveNodes(self, query):
        self._oprot.writeMessageBegin('RetrieveNodes', TMessageType.CALL, self._seqid)
        args = RetrieveNodes_args()
        args.query = query
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveNodes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveNodes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveNodes failed: unknown result")

    def RetrieveNodesByGraphID(self, graphid, limit):
        """
        Parameters:
         - graphid
         - limit
        """
        self.send_RetrieveNodesByGraphID(graphid, limit)
        return self.recv_RetrieveNodesByGraphID()

    def send_RetrieveNodesByGraphID(self, graphid, limit):
        self._oprot.writeMessageBegin('RetrieveNodesByGraphID', TMessageType.CALL, self._seqid)
        args = RetrieveNodesByGraphID_args()
        args.graphid = graphid
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveNodesByGraphID(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveNodesByGraphID_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveNodesByGraphID failed: unknown result")

    def RetrieveNodesByAoKID(self, id, limit):
        """
        Parameters:
         - id
         - limit
        """
        self.send_RetrieveNodesByAoKID(id, limit)
        return self.recv_RetrieveNodesByAoKID()

    def send_RetrieveNodesByAoKID(self, id, limit):
        self._oprot.writeMessageBegin('RetrieveNodesByAoKID', TMessageType.CALL, self._seqid)
        args = RetrieveNodesByAoKID_args()
        args.id = id
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveNodesByAoKID(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveNodesByAoKID_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveNodesByAoKID failed: unknown result")

    def RetrieveNodesByAllSubjectSpecializationOf(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveNodesByAllSubjectSpecializationOf(criteria, limit)
        return self.recv_RetrieveNodesByAllSubjectSpecializationOf()

    def send_RetrieveNodesByAllSubjectSpecializationOf(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveNodesByAllSubjectSpecializationOf', TMessageType.CALL, self._seqid)
        args = RetrieveNodesByAllSubjectSpecializationOf_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveNodesByAllSubjectSpecializationOf(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveNodesByAllSubjectSpecializationOf_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveNodesByAllSubjectSpecializationOf failed: unknown result")

    def RetrieveNodesByAnySubjectSpecializationOf(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveNodesByAnySubjectSpecializationOf(criteria, limit)
        return self.recv_RetrieveNodesByAnySubjectSpecializationOf()

    def send_RetrieveNodesByAnySubjectSpecializationOf(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveNodesByAnySubjectSpecializationOf', TMessageType.CALL, self._seqid)
        args = RetrieveNodesByAnySubjectSpecializationOf_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveNodesByAnySubjectSpecializationOf(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveNodesByAnySubjectSpecializationOf_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveNodesByAnySubjectSpecializationOf failed: unknown result")

    def RetrieveNodesByAnyNameLabels(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveNodesByAnyNameLabels(criteria, limit)
        return self.recv_RetrieveNodesByAnyNameLabels()

    def send_RetrieveNodesByAnyNameLabels(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveNodesByAnyNameLabels', TMessageType.CALL, self._seqid)
        args = RetrieveNodesByAnyNameLabels_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveNodesByAnyNameLabels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveNodesByAnyNameLabels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveNodesByAnyNameLabels failed: unknown result")

    def RetrieveNodesByAllNameLabels(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveNodesByAllNameLabels(criteria, limit)
        return self.recv_RetrieveNodesByAllNameLabels()

    def send_RetrieveNodesByAllNameLabels(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveNodesByAllNameLabels', TMessageType.CALL, self._seqid)
        args = RetrieveNodesByAllNameLabels_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveNodesByAllNameLabels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveNodesByAllNameLabels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveNodesByAllNameLabels failed: unknown result")

    def RetrieveNodesTruthValue(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveNodesTruthValue(criteria, limit)
        return self.recv_RetrieveNodesTruthValue()

    def send_RetrieveNodesTruthValue(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveNodesTruthValue', TMessageType.CALL, self._seqid)
        args = RetrieveNodesTruthValue_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveNodesTruthValue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveNodesTruthValue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveNodesTruthValue failed: unknown result")

    def RetrieveNodesByEvaluation(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveNodesByEvaluation(criteria, limit)
        return self.recv_RetrieveNodesByEvaluation()

    def send_RetrieveNodesByEvaluation(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveNodesByEvaluation', TMessageType.CALL, self._seqid)
        args = RetrieveNodesByEvaluation_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveNodesByEvaluation(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveNodesByEvaluation_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveNodesByEvaluation failed: unknown result")

    def RetrieveNodesByDateTime(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveNodesByDateTime(criteria, limit)
        return self.recv_RetrieveNodesByDateTime()

    def send_RetrieveNodesByDateTime(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveNodesByDateTime', TMessageType.CALL, self._seqid)
        args = RetrieveNodesByDateTime_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveNodesByDateTime(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveNodesByDateTime_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveNodesByDateTime failed: unknown result")

    def RetrieveNodesByAge(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveNodesByAge(criteria, limit)
        return self.recv_RetrieveNodesByAge()

    def send_RetrieveNodesByAge(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveNodesByAge', TMessageType.CALL, self._seqid)
        args = RetrieveNodesByAge_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveNodesByAge(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveNodesByAge_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveNodesByAge failed: unknown result")

    def RetrieveNodesAttentionLevel(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveNodesAttentionLevel(criteria, limit)
        return self.recv_RetrieveNodesAttentionLevel()

    def send_RetrieveNodesAttentionLevel(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveNodesAttentionLevel', TMessageType.CALL, self._seqid)
        args = RetrieveNodesAttentionLevel_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveNodesAttentionLevel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveNodesAttentionLevel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveNodesAttentionLevel failed: unknown result")

    def RetrieveNodesByScratchPad(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveNodesByScratchPad(criteria, limit)
        return self.recv_RetrieveNodesByScratchPad()

    def send_RetrieveNodesByScratchPad(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveNodesByScratchPad', TMessageType.CALL, self._seqid)
        args = RetrieveNodesByScratchPad_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveNodesByScratchPad(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveNodesByScratchPad_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveNodesByScratchPad failed: unknown result")

    def RetrieveNodesByUser(self, userid, limit):
        """
        Parameters:
         - userid
         - limit
        """
        self.send_RetrieveNodesByUser(userid, limit)
        return self.recv_RetrieveNodesByUser()

    def send_RetrieveNodesByUser(self, userid, limit):
        self._oprot.writeMessageBegin('RetrieveNodesByUser', TMessageType.CALL, self._seqid)
        args = RetrieveNodesByUser_args()
        args.userid = userid
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveNodesByUser(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveNodesByUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveNodesByUser failed: unknown result")

    def RetrieveNodesCreateByUser(self, userid, limit):
        """
        Parameters:
         - userid
         - limit
        """
        self.send_RetrieveNodesCreateByUser(userid, limit)
        return self.recv_RetrieveNodesCreateByUser()

    def send_RetrieveNodesCreateByUser(self, userid, limit):
        self._oprot.writeMessageBegin('RetrieveNodesCreateByUser', TMessageType.CALL, self._seqid)
        args = RetrieveNodesCreateByUser_args()
        args.userid = userid
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveNodesCreateByUser(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveNodesCreateByUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveNodesCreateByUser failed: unknown result")

    def RetrieveNodesCreatedByNiHA(self, limit):
        """
        Parameters:
         - limit
        """
        self.send_RetrieveNodesCreatedByNiHA(limit)
        return self.recv_RetrieveNodesCreatedByNiHA()

    def send_RetrieveNodesCreatedByNiHA(self, limit):
        self._oprot.writeMessageBegin('RetrieveNodesCreatedByNiHA', TMessageType.CALL, self._seqid)
        args = RetrieveNodesCreatedByNiHA_args()
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveNodesCreatedByNiHA(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveNodesCreatedByNiHA_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveNodesCreatedByNiHA failed: unknown result")

    def RetrieveNodesCreatedByNiHAWithUser(self, when_this_user_was_signedin, limit):
        """
        Parameters:
         - when_this_user_was_signedin
         - limit
        """
        self.send_RetrieveNodesCreatedByNiHAWithUser(when_this_user_was_signedin, limit)
        return self.recv_RetrieveNodesCreatedByNiHAWithUser()

    def send_RetrieveNodesCreatedByNiHAWithUser(self, when_this_user_was_signedin, limit):
        self._oprot.writeMessageBegin('RetrieveNodesCreatedByNiHAWithUser', TMessageType.CALL, self._seqid)
        args = RetrieveNodesCreatedByNiHAWithUser_args()
        args.when_this_user_was_signedin = when_this_user_was_signedin
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveNodesCreatedByNiHAWithUser(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveNodesCreatedByNiHAWithUser_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveNodesCreatedByNiHAWithUser failed: unknown result")

    def RetrieveNodesCreatedByNiHAWithCriteria(self, criteria, limit):
        """
        Parameters:
         - criteria
         - limit
        """
        self.send_RetrieveNodesCreatedByNiHAWithCriteria(criteria, limit)
        return self.recv_RetrieveNodesCreatedByNiHAWithCriteria()

    def send_RetrieveNodesCreatedByNiHAWithCriteria(self, criteria, limit):
        self._oprot.writeMessageBegin('RetrieveNodesCreatedByNiHAWithCriteria', TMessageType.CALL, self._seqid)
        args = RetrieveNodesCreatedByNiHAWithCriteria_args()
        args.criteria = criteria
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetrieveNodesCreatedByNiHAWithCriteria(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetrieveNodesCreatedByNiHAWithCriteria_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetrieveNodesCreatedByNiHAWithCriteria failed: unknown result")

    def RetriveNodesUniqueListOfAllSpecializationLabels(self, limit):
        """
        Parameters:
         - limit
        """
        self.send_RetriveNodesUniqueListOfAllSpecializationLabels(limit)
        return self.recv_RetriveNodesUniqueListOfAllSpecializationLabels()

    def send_RetriveNodesUniqueListOfAllSpecializationLabels(self, limit):
        self._oprot.writeMessageBegin('RetriveNodesUniqueListOfAllSpecializationLabels', TMessageType.CALL, self._seqid)
        args = RetriveNodesUniqueListOfAllSpecializationLabels_args()
        args.limit = limit
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RetriveNodesUniqueListOfAllSpecializationLabels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RetriveNodesUniqueListOfAllSpecializationLabels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RetriveNodesUniqueListOfAllSpecializationLabels failed: unknown result")

    def UpdateNode(self, node):
        """
        Parameters:
         - node
        """
        self.send_UpdateNode(node)
        return self.recv_UpdateNode()

    def send_UpdateNode(self, node):
        self._oprot.writeMessageBegin('UpdateNode', TMessageType.CALL, self._seqid)
        args = UpdateNode_args()
        args.node = node
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_UpdateNode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = UpdateNode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "UpdateNode failed: unknown result")

    def DeleteNode(self, criteria):
        """
        Parameters:
         - criteria
        """
        self.send_DeleteNode(criteria)
        return self.recv_DeleteNode()

    def send_DeleteNode(self, criteria):
        self._oprot.writeMessageBegin('DeleteNode', TMessageType.CALL, self._seqid)
        args = DeleteNode_args()
        args.criteria = criteria
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_DeleteNode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = DeleteNode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "DeleteNode failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["GetFrequency"] = Processor.process_GetFrequency
        self._processMap["GetFrequencyByUser"] = Processor.process_GetFrequencyByUser
        self._processMap["SignIn"] = Processor.process_SignIn
        self._processMap["SignOut"] = Processor.process_SignOut
        self._processMap["Ping"] = Processor.process_Ping
        self._processMap["CreateGraph"] = Processor.process_CreateGraph
        self._processMap["UpdateGraph"] = Processor.process_UpdateGraph
        self._processMap["DeleteGraph"] = Processor.process_DeleteGraph
        self._processMap["RetrieveGraphs"] = Processor.process_RetrieveGraphs
        self._processMap["RetrieveGraphByGraphID"] = Processor.process_RetrieveGraphByGraphID
        self._processMap["RetrieveGraphsByAoKID"] = Processor.process_RetrieveGraphsByAoKID
        self._processMap["RetrieveGraphsByAllSubjectSpecializationOf"] = Processor.process_RetrieveGraphsByAllSubjectSpecializationOf
        self._processMap["RetrieveGraphsByAnySubjectSpecializationOf"] = Processor.process_RetrieveGraphsByAnySubjectSpecializationOf
        self._processMap["RetrieveGraphsByAllNameLabels"] = Processor.process_RetrieveGraphsByAllNameLabels
        self._processMap["RetrieveGraphsByAnyNameLabels"] = Processor.process_RetrieveGraphsByAnyNameLabels
        self._processMap["RetrieveGraphsByTypes"] = Processor.process_RetrieveGraphsByTypes
        self._processMap["RetrieveGraphsByTypeAndName"] = Processor.process_RetrieveGraphsByTypeAndName
        self._processMap["GetGraphByTypeAndSpecialization"] = Processor.process_GetGraphByTypeAndSpecialization
        self._processMap["RetrieveGraphsCreatedByNiHA"] = Processor.process_RetrieveGraphsCreatedByNiHA
        self._processMap["RetrieveGraphsCreatedByNiHAWithUser"] = Processor.process_RetrieveGraphsCreatedByNiHAWithUser
        self._processMap["RetrieveGraphsCreatedByNiHAWithCriteria"] = Processor.process_RetrieveGraphsCreatedByNiHAWithCriteria
        self._processMap["RetriveGraphsUniqueListOfAllSubjectSpecializationLabels"] = Processor.process_RetriveGraphsUniqueListOfAllSubjectSpecializationLabels
        self._processMap["CreateRelation"] = Processor.process_CreateRelation
        self._processMap["CreateRelationWithNodes"] = Processor.process_CreateRelationWithNodes
        self._processMap["UpdateRelation"] = Processor.process_UpdateRelation
        self._processMap["DeleteRelation"] = Processor.process_DeleteRelation
        self._processMap["RetrieveRelationByNeo4jId"] = Processor.process_RetrieveRelationByNeo4jId
        self._processMap["RetrieveRelations"] = Processor.process_RetrieveRelations
        self._processMap["RetrieveRelationsByGraphID"] = Processor.process_RetrieveRelationsByGraphID
        self._processMap["RetrieveRelationsByAoKID"] = Processor.process_RetrieveRelationsByAoKID
        self._processMap["RetrieveRelationsBySpecializationOf"] = Processor.process_RetrieveRelationsBySpecializationOf
        self._processMap["RetrieveRelationsNameLabels"] = Processor.process_RetrieveRelationsNameLabels
        self._processMap["RetrieveRelationsTruthValue"] = Processor.process_RetrieveRelationsTruthValue
        self._processMap["RetrieveRelationsByDateTime"] = Processor.process_RetrieveRelationsByDateTime
        self._processMap["RetrieveRelationsByAge"] = Processor.process_RetrieveRelationsByAge
        self._processMap["RetrieveRelationsAttentionLevel"] = Processor.process_RetrieveRelationsAttentionLevel
        self._processMap["RetrieveRelationsScratchPad"] = Processor.process_RetrieveRelationsScratchPad
        self._processMap["RetrieveRelationsByUser"] = Processor.process_RetrieveRelationsByUser
        self._processMap["RetrieveRelationsCreateByUser"] = Processor.process_RetrieveRelationsCreateByUser
        self._processMap["RetrieveRelationsCreatedByNiHA"] = Processor.process_RetrieveRelationsCreatedByNiHA
        self._processMap["RetrieveRelationsCreatedByNiHAWithUser"] = Processor.process_RetrieveRelationsCreatedByNiHAWithUser
        self._processMap["RetrieveRelationsCreatedByNiHAWithCriteria"] = Processor.process_RetrieveRelationsCreatedByNiHAWithCriteria
        self._processMap["RetrieveRelationsUniqueListOfAllSpecializationLabels"] = Processor.process_RetrieveRelationsUniqueListOfAllSpecializationLabels
        self._processMap["CreateNodes"] = Processor.process_CreateNodes
        self._processMap["RetrieveByNeo4jId"] = Processor.process_RetrieveByNeo4jId
        self._processMap["RetrieveNodes"] = Processor.process_RetrieveNodes
        self._processMap["RetrieveNodesByGraphID"] = Processor.process_RetrieveNodesByGraphID
        self._processMap["RetrieveNodesByAoKID"] = Processor.process_RetrieveNodesByAoKID
        self._processMap["RetrieveNodesByAllSubjectSpecializationOf"] = Processor.process_RetrieveNodesByAllSubjectSpecializationOf
        self._processMap["RetrieveNodesByAnySubjectSpecializationOf"] = Processor.process_RetrieveNodesByAnySubjectSpecializationOf
        self._processMap["RetrieveNodesByAnyNameLabels"] = Processor.process_RetrieveNodesByAnyNameLabels
        self._processMap["RetrieveNodesByAllNameLabels"] = Processor.process_RetrieveNodesByAllNameLabels
        self._processMap["RetrieveNodesTruthValue"] = Processor.process_RetrieveNodesTruthValue
        self._processMap["RetrieveNodesByEvaluation"] = Processor.process_RetrieveNodesByEvaluation
        self._processMap["RetrieveNodesByDateTime"] = Processor.process_RetrieveNodesByDateTime
        self._processMap["RetrieveNodesByAge"] = Processor.process_RetrieveNodesByAge
        self._processMap["RetrieveNodesAttentionLevel"] = Processor.process_RetrieveNodesAttentionLevel
        self._processMap["RetrieveNodesByScratchPad"] = Processor.process_RetrieveNodesByScratchPad
        self._processMap["RetrieveNodesByUser"] = Processor.process_RetrieveNodesByUser
        self._processMap["RetrieveNodesCreateByUser"] = Processor.process_RetrieveNodesCreateByUser
        self._processMap["RetrieveNodesCreatedByNiHA"] = Processor.process_RetrieveNodesCreatedByNiHA
        self._processMap["RetrieveNodesCreatedByNiHAWithUser"] = Processor.process_RetrieveNodesCreatedByNiHAWithUser
        self._processMap["RetrieveNodesCreatedByNiHAWithCriteria"] = Processor.process_RetrieveNodesCreatedByNiHAWithCriteria
        self._processMap["RetriveNodesUniqueListOfAllSpecializationLabels"] = Processor.process_RetriveNodesUniqueListOfAllSpecializationLabels
        self._processMap["UpdateNode"] = Processor.process_UpdateNode
        self._processMap["DeleteNode"] = Processor.process_DeleteNode

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_GetFrequency(self, seqid, iprot, oprot):
        args = GetFrequency_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetFrequency_result()
        try:
            result.success = self._handler.GetFrequency()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetFrequency", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetFrequencyByUser(self, seqid, iprot, oprot):
        args = GetFrequencyByUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetFrequencyByUser_result()
        try:
            result.success = self._handler.GetFrequencyByUser(args.user)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetFrequencyByUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SignIn(self, seqid, iprot, oprot):
        args = SignIn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SignIn_result()
        try:
            result.success = self._handler.SignIn(args.user, args.Password)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SignIn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_SignOut(self, seqid, iprot, oprot):
        args = SignOut_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = SignOut_result()
        try:
            result.success = self._handler.SignOut(args.user)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("SignOut", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_Ping(self, seqid, iprot, oprot):
        args = Ping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = Ping_result()
        try:
            self._handler.Ping()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("Ping", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CreateGraph(self, seqid, iprot, oprot):
        args = CreateGraph_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CreateGraph_result()
        try:
            result.success = self._handler.CreateGraph(args.graph)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CreateGraph", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_UpdateGraph(self, seqid, iprot, oprot):
        args = UpdateGraph_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = UpdateGraph_result()
        try:
            result.success = self._handler.UpdateGraph(args.graph)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("UpdateGraph", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_DeleteGraph(self, seqid, iprot, oprot):
        args = DeleteGraph_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = DeleteGraph_result()
        try:
            result.success = self._handler.DeleteGraph(args.criteria)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("DeleteGraph", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveGraphs(self, seqid, iprot, oprot):
        args = RetrieveGraphs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveGraphs_result()
        try:
            result.success = self._handler.RetrieveGraphs(args.query)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveGraphs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveGraphByGraphID(self, seqid, iprot, oprot):
        args = RetrieveGraphByGraphID_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveGraphByGraphID_result()
        try:
            result.success = self._handler.RetrieveGraphByGraphID(args.graphid, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveGraphByGraphID", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveGraphsByAoKID(self, seqid, iprot, oprot):
        args = RetrieveGraphsByAoKID_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveGraphsByAoKID_result()
        try:
            result.success = self._handler.RetrieveGraphsByAoKID(args.id, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveGraphsByAoKID", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveGraphsByAllSubjectSpecializationOf(self, seqid, iprot, oprot):
        args = RetrieveGraphsByAllSubjectSpecializationOf_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveGraphsByAllSubjectSpecializationOf_result()
        try:
            result.success = self._handler.RetrieveGraphsByAllSubjectSpecializationOf(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveGraphsByAllSubjectSpecializationOf", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveGraphsByAnySubjectSpecializationOf(self, seqid, iprot, oprot):
        args = RetrieveGraphsByAnySubjectSpecializationOf_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveGraphsByAnySubjectSpecializationOf_result()
        try:
            result.success = self._handler.RetrieveGraphsByAnySubjectSpecializationOf(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveGraphsByAnySubjectSpecializationOf", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveGraphsByAllNameLabels(self, seqid, iprot, oprot):
        args = RetrieveGraphsByAllNameLabels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveGraphsByAllNameLabels_result()
        try:
            result.success = self._handler.RetrieveGraphsByAllNameLabels(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveGraphsByAllNameLabels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveGraphsByAnyNameLabels(self, seqid, iprot, oprot):
        args = RetrieveGraphsByAnyNameLabels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveGraphsByAnyNameLabels_result()
        try:
            result.success = self._handler.RetrieveGraphsByAnyNameLabels(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveGraphsByAnyNameLabels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveGraphsByTypes(self, seqid, iprot, oprot):
        args = RetrieveGraphsByTypes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveGraphsByTypes_result()
        try:
            result.success = self._handler.RetrieveGraphsByTypes(args.types, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveGraphsByTypes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveGraphsByTypeAndName(self, seqid, iprot, oprot):
        args = RetrieveGraphsByTypeAndName_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveGraphsByTypeAndName_result()
        try:
            result.success = self._handler.RetrieveGraphsByTypeAndName(args.type, args.name, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveGraphsByTypeAndName", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetGraphByTypeAndSpecialization(self, seqid, iprot, oprot):
        args = GetGraphByTypeAndSpecialization_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetGraphByTypeAndSpecialization_result()
        try:
            result.success = self._handler.GetGraphByTypeAndSpecialization(args.type, args.specialization_criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetGraphByTypeAndSpecialization", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveGraphsCreatedByNiHA(self, seqid, iprot, oprot):
        args = RetrieveGraphsCreatedByNiHA_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveGraphsCreatedByNiHA_result()
        try:
            result.success = self._handler.RetrieveGraphsCreatedByNiHA(args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveGraphsCreatedByNiHA", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveGraphsCreatedByNiHAWithUser(self, seqid, iprot, oprot):
        args = RetrieveGraphsCreatedByNiHAWithUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveGraphsCreatedByNiHAWithUser_result()
        try:
            result.success = self._handler.RetrieveGraphsCreatedByNiHAWithUser(args.when_this_user_was_signedin, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveGraphsCreatedByNiHAWithUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveGraphsCreatedByNiHAWithCriteria(self, seqid, iprot, oprot):
        args = RetrieveGraphsCreatedByNiHAWithCriteria_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveGraphsCreatedByNiHAWithCriteria_result()
        try:
            result.success = self._handler.RetrieveGraphsCreatedByNiHAWithCriteria(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveGraphsCreatedByNiHAWithCriteria", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetriveGraphsUniqueListOfAllSubjectSpecializationLabels(self, seqid, iprot, oprot):
        args = RetriveGraphsUniqueListOfAllSubjectSpecializationLabels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetriveGraphsUniqueListOfAllSubjectSpecializationLabels_result()
        try:
            result.success = self._handler.RetriveGraphsUniqueListOfAllSubjectSpecializationLabels(args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetriveGraphsUniqueListOfAllSubjectSpecializationLabels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CreateRelation(self, seqid, iprot, oprot):
        args = CreateRelation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CreateRelation_result()
        try:
            result.success = self._handler.CreateRelation(args.relations)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CreateRelation", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CreateRelationWithNodes(self, seqid, iprot, oprot):
        args = CreateRelationWithNodes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CreateRelationWithNodes_result()
        try:
            result.success = self._handler.CreateRelationWithNodes(args.source_node, args.target_node)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CreateRelationWithNodes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_UpdateRelation(self, seqid, iprot, oprot):
        args = UpdateRelation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = UpdateRelation_result()
        try:
            result.success = self._handler.UpdateRelation(args.relation)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("UpdateRelation", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_DeleteRelation(self, seqid, iprot, oprot):
        args = DeleteRelation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = DeleteRelation_result()
        try:
            result.success = self._handler.DeleteRelation(args.criteria)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("DeleteRelation", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveRelationByNeo4jId(self, seqid, iprot, oprot):
        args = RetrieveRelationByNeo4jId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveRelationByNeo4jId_result()
        try:
            result.success = self._handler.RetrieveRelationByNeo4jId(args.id, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveRelationByNeo4jId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveRelations(self, seqid, iprot, oprot):
        args = RetrieveRelations_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveRelations_result()
        try:
            result.success = self._handler.RetrieveRelations(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveRelations", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveRelationsByGraphID(self, seqid, iprot, oprot):
        args = RetrieveRelationsByGraphID_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveRelationsByGraphID_result()
        try:
            result.success = self._handler.RetrieveRelationsByGraphID(args.graphid, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveRelationsByGraphID", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveRelationsByAoKID(self, seqid, iprot, oprot):
        args = RetrieveRelationsByAoKID_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveRelationsByAoKID_result()
        try:
            result.success = self._handler.RetrieveRelationsByAoKID(args.id, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveRelationsByAoKID", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveRelationsBySpecializationOf(self, seqid, iprot, oprot):
        args = RetrieveRelationsBySpecializationOf_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveRelationsBySpecializationOf_result()
        try:
            result.success = self._handler.RetrieveRelationsBySpecializationOf(args.subject_specialization, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveRelationsBySpecializationOf", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveRelationsNameLabels(self, seqid, iprot, oprot):
        args = RetrieveRelationsNameLabels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveRelationsNameLabels_result()
        try:
            result.success = self._handler.RetrieveRelationsNameLabels(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveRelationsNameLabels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveRelationsTruthValue(self, seqid, iprot, oprot):
        args = RetrieveRelationsTruthValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveRelationsTruthValue_result()
        try:
            result.success = self._handler.RetrieveRelationsTruthValue(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveRelationsTruthValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveRelationsByDateTime(self, seqid, iprot, oprot):
        args = RetrieveRelationsByDateTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveRelationsByDateTime_result()
        try:
            result.success = self._handler.RetrieveRelationsByDateTime(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveRelationsByDateTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveRelationsByAge(self, seqid, iprot, oprot):
        args = RetrieveRelationsByAge_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveRelationsByAge_result()
        try:
            result.success = self._handler.RetrieveRelationsByAge(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveRelationsByAge", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveRelationsAttentionLevel(self, seqid, iprot, oprot):
        args = RetrieveRelationsAttentionLevel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveRelationsAttentionLevel_result()
        try:
            result.success = self._handler.RetrieveRelationsAttentionLevel(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveRelationsAttentionLevel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveRelationsScratchPad(self, seqid, iprot, oprot):
        args = RetrieveRelationsScratchPad_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveRelationsScratchPad_result()
        try:
            result.success = self._handler.RetrieveRelationsScratchPad(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveRelationsScratchPad", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveRelationsByUser(self, seqid, iprot, oprot):
        args = RetrieveRelationsByUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveRelationsByUser_result()
        try:
            result.success = self._handler.RetrieveRelationsByUser(args.userid, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveRelationsByUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveRelationsCreateByUser(self, seqid, iprot, oprot):
        args = RetrieveRelationsCreateByUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveRelationsCreateByUser_result()
        try:
            result.success = self._handler.RetrieveRelationsCreateByUser(args.userid, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveRelationsCreateByUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveRelationsCreatedByNiHA(self, seqid, iprot, oprot):
        args = RetrieveRelationsCreatedByNiHA_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveRelationsCreatedByNiHA_result()
        try:
            result.success = self._handler.RetrieveRelationsCreatedByNiHA(args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveRelationsCreatedByNiHA", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveRelationsCreatedByNiHAWithUser(self, seqid, iprot, oprot):
        args = RetrieveRelationsCreatedByNiHAWithUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveRelationsCreatedByNiHAWithUser_result()
        try:
            result.success = self._handler.RetrieveRelationsCreatedByNiHAWithUser(args.when_this_user_was_signedin, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveRelationsCreatedByNiHAWithUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveRelationsCreatedByNiHAWithCriteria(self, seqid, iprot, oprot):
        args = RetrieveRelationsCreatedByNiHAWithCriteria_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveRelationsCreatedByNiHAWithCriteria_result()
        try:
            result.success = self._handler.RetrieveRelationsCreatedByNiHAWithCriteria(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveRelationsCreatedByNiHAWithCriteria", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveRelationsUniqueListOfAllSpecializationLabels(self, seqid, iprot, oprot):
        args = RetrieveRelationsUniqueListOfAllSpecializationLabels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveRelationsUniqueListOfAllSpecializationLabels_result()
        try:
            result.success = self._handler.RetrieveRelationsUniqueListOfAllSpecializationLabels(args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveRelationsUniqueListOfAllSpecializationLabels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CreateNodes(self, seqid, iprot, oprot):
        args = CreateNodes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CreateNodes_result()
        try:
            result.success = self._handler.CreateNodes(args.node)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CreateNodes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveByNeo4jId(self, seqid, iprot, oprot):
        args = RetrieveByNeo4jId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveByNeo4jId_result()
        try:
            result.success = self._handler.RetrieveByNeo4jId(args.id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveByNeo4jId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveNodes(self, seqid, iprot, oprot):
        args = RetrieveNodes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveNodes_result()
        try:
            result.success = self._handler.RetrieveNodes(args.query)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveNodes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveNodesByGraphID(self, seqid, iprot, oprot):
        args = RetrieveNodesByGraphID_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveNodesByGraphID_result()
        try:
            result.success = self._handler.RetrieveNodesByGraphID(args.graphid, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveNodesByGraphID", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveNodesByAoKID(self, seqid, iprot, oprot):
        args = RetrieveNodesByAoKID_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveNodesByAoKID_result()
        try:
            result.success = self._handler.RetrieveNodesByAoKID(args.id, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveNodesByAoKID", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveNodesByAllSubjectSpecializationOf(self, seqid, iprot, oprot):
        args = RetrieveNodesByAllSubjectSpecializationOf_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveNodesByAllSubjectSpecializationOf_result()
        try:
            result.success = self._handler.RetrieveNodesByAllSubjectSpecializationOf(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveNodesByAllSubjectSpecializationOf", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveNodesByAnySubjectSpecializationOf(self, seqid, iprot, oprot):
        args = RetrieveNodesByAnySubjectSpecializationOf_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveNodesByAnySubjectSpecializationOf_result()
        try:
            result.success = self._handler.RetrieveNodesByAnySubjectSpecializationOf(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveNodesByAnySubjectSpecializationOf", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveNodesByAnyNameLabels(self, seqid, iprot, oprot):
        args = RetrieveNodesByAnyNameLabels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveNodesByAnyNameLabels_result()
        try:
            result.success = self._handler.RetrieveNodesByAnyNameLabels(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveNodesByAnyNameLabels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveNodesByAllNameLabels(self, seqid, iprot, oprot):
        args = RetrieveNodesByAllNameLabels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveNodesByAllNameLabels_result()
        try:
            result.success = self._handler.RetrieveNodesByAllNameLabels(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveNodesByAllNameLabels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveNodesTruthValue(self, seqid, iprot, oprot):
        args = RetrieveNodesTruthValue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveNodesTruthValue_result()
        try:
            result.success = self._handler.RetrieveNodesTruthValue(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveNodesTruthValue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveNodesByEvaluation(self, seqid, iprot, oprot):
        args = RetrieveNodesByEvaluation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveNodesByEvaluation_result()
        try:
            result.success = self._handler.RetrieveNodesByEvaluation(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveNodesByEvaluation", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveNodesByDateTime(self, seqid, iprot, oprot):
        args = RetrieveNodesByDateTime_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveNodesByDateTime_result()
        try:
            result.success = self._handler.RetrieveNodesByDateTime(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveNodesByDateTime", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveNodesByAge(self, seqid, iprot, oprot):
        args = RetrieveNodesByAge_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveNodesByAge_result()
        try:
            result.success = self._handler.RetrieveNodesByAge(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveNodesByAge", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveNodesAttentionLevel(self, seqid, iprot, oprot):
        args = RetrieveNodesAttentionLevel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveNodesAttentionLevel_result()
        try:
            result.success = self._handler.RetrieveNodesAttentionLevel(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveNodesAttentionLevel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveNodesByScratchPad(self, seqid, iprot, oprot):
        args = RetrieveNodesByScratchPad_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveNodesByScratchPad_result()
        try:
            result.success = self._handler.RetrieveNodesByScratchPad(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveNodesByScratchPad", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveNodesByUser(self, seqid, iprot, oprot):
        args = RetrieveNodesByUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveNodesByUser_result()
        try:
            result.success = self._handler.RetrieveNodesByUser(args.userid, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveNodesByUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveNodesCreateByUser(self, seqid, iprot, oprot):
        args = RetrieveNodesCreateByUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveNodesCreateByUser_result()
        try:
            result.success = self._handler.RetrieveNodesCreateByUser(args.userid, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveNodesCreateByUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveNodesCreatedByNiHA(self, seqid, iprot, oprot):
        args = RetrieveNodesCreatedByNiHA_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveNodesCreatedByNiHA_result()
        try:
            result.success = self._handler.RetrieveNodesCreatedByNiHA(args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveNodesCreatedByNiHA", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveNodesCreatedByNiHAWithUser(self, seqid, iprot, oprot):
        args = RetrieveNodesCreatedByNiHAWithUser_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveNodesCreatedByNiHAWithUser_result()
        try:
            result.success = self._handler.RetrieveNodesCreatedByNiHAWithUser(args.when_this_user_was_signedin, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveNodesCreatedByNiHAWithUser", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetrieveNodesCreatedByNiHAWithCriteria(self, seqid, iprot, oprot):
        args = RetrieveNodesCreatedByNiHAWithCriteria_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetrieveNodesCreatedByNiHAWithCriteria_result()
        try:
            result.success = self._handler.RetrieveNodesCreatedByNiHAWithCriteria(args.criteria, args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetrieveNodesCreatedByNiHAWithCriteria", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RetriveNodesUniqueListOfAllSpecializationLabels(self, seqid, iprot, oprot):
        args = RetriveNodesUniqueListOfAllSpecializationLabels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RetriveNodesUniqueListOfAllSpecializationLabels_result()
        try:
            result.success = self._handler.RetriveNodesUniqueListOfAllSpecializationLabels(args.limit)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RetriveNodesUniqueListOfAllSpecializationLabels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_UpdateNode(self, seqid, iprot, oprot):
        args = UpdateNode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = UpdateNode_result()
        try:
            result.success = self._handler.UpdateNode(args.node)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("UpdateNode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_DeleteNode(self, seqid, iprot, oprot):
        args = DeleteNode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = DeleteNode_result()
        try:
            result.success = self._handler.DeleteNode(args.criteria)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("DeleteNode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class GetFrequency_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetFrequency_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetFrequency_args)
GetFrequency_args.thrift_spec = (
)


class GetFrequency_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetFrequency_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetFrequency_result)
GetFrequency_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class GetFrequencyByUser_args(object):
    """
    Attributes:
     - user
    """


    def __init__(self, user=None,):
        self.user = user

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.user = TUser()
                    self.user.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetFrequencyByUser_args')
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRUCT, 1)
            self.user.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetFrequencyByUser_args)
GetFrequencyByUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'user', [TUser, None], None, ),  # 1
)


class GetFrequencyByUser_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetFrequencyByUser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetFrequencyByUser_result)
GetFrequencyByUser_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SignIn_args(object):
    """
    Attributes:
     - user
     - Password
    """


    def __init__(self, user=None, Password=None,):
        self.user = user
        self.Password = Password

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.user = TUser()
                    self.user.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.Password = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SignIn_args')
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRUCT, 1)
            self.user.write(oprot)
            oprot.writeFieldEnd()
        if self.Password is not None:
            oprot.writeFieldBegin('Password', TType.STRING, 2)
            oprot.writeString(self.Password.encode('utf-8') if sys.version_info[0] == 2 else self.Password)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SignIn_args)
SignIn_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'user', [TUser, None], None, ),  # 1
    (2, TType.STRING, 'Password', 'UTF8', None, ),  # 2
)


class SignIn_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SignIn_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SignIn_result)
SignIn_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class SignOut_args(object):
    """
    Attributes:
     - user
    """


    def __init__(self, user=None,):
        self.user = user

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.user = TUser()
                    self.user.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SignOut_args')
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRUCT, 1)
            self.user.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SignOut_args)
SignOut_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'user', [TUser, None], None, ),  # 1
)


class SignOut_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SignOut_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(SignOut_result)
SignOut_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class Ping_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Ping_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Ping_args)
Ping_args.thrift_spec = (
)


class Ping_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Ping_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Ping_result)
Ping_result.thrift_spec = (
)


class CreateGraph_args(object):
    """
    Attributes:
     - graph
    """


    def __init__(self, graph=None,):
        self.graph = graph

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.graph = TGraph()
                    self.graph.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateGraph_args')
        if self.graph is not None:
            oprot.writeFieldBegin('graph', TType.STRUCT, 1)
            self.graph.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateGraph_args)
CreateGraph_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'graph', [TGraph, None], None, ),  # 1
)


class CreateGraph_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateGraph_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateGraph_result)
CreateGraph_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class UpdateGraph_args(object):
    """
    Attributes:
     - graph
    """


    def __init__(self, graph=None,):
        self.graph = graph

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.graph = TGraph()
                    self.graph.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UpdateGraph_args')
        if self.graph is not None:
            oprot.writeFieldBegin('graph', TType.STRUCT, 1)
            self.graph.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(UpdateGraph_args)
UpdateGraph_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'graph', [TGraph, None], None, ),  # 1
)


class UpdateGraph_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UpdateGraph_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(UpdateGraph_result)
UpdateGraph_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class DeleteGraph_args(object):
    """
    Attributes:
     - criteria
    """


    def __init__(self, criteria=None,):
        self.criteria = criteria

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteGraph_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DeleteGraph_args)
DeleteGraph_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
)


class DeleteGraph_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteGraph_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DeleteGraph_result)
DeleteGraph_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class RetrieveGraphs_args(object):
    """
    Attributes:
     - query
    """


    def __init__(self, query=None,):
        self.query = query

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.query = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphs_args')
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRING, 1)
            oprot.writeString(self.query.encode('utf-8') if sys.version_info[0] == 2 else self.query)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphs_args)
RetrieveGraphs_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'query', 'UTF8', None, ),  # 1
)


class RetrieveGraphs_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype180, _size177) = iprot.readListBegin()
                    for _i181 in range(_size177):
                        _elem182 = TGraph()
                        _elem182.read(iprot)
                        self.success.append(_elem182)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter183 in self.success:
                iter183.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphs_result)
RetrieveGraphs_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TGraph, None], False), None, ),  # 0
)


class RetrieveGraphByGraphID_args(object):
    """
    Attributes:
     - graphid
     - limit
    """


    def __init__(self, graphid=None, limit=None,):
        self.graphid = graphid
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.graphid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphByGraphID_args')
        if self.graphid is not None:
            oprot.writeFieldBegin('graphid', TType.STRING, 1)
            oprot.writeString(self.graphid.encode('utf-8') if sys.version_info[0] == 2 else self.graphid)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphByGraphID_args)
RetrieveGraphByGraphID_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'graphid', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveGraphByGraphID_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TGraph()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphByGraphID_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphByGraphID_result)
RetrieveGraphByGraphID_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TGraph, None], None, ),  # 0
)


class RetrieveGraphsByAoKID_args(object):
    """
    Attributes:
     - id
     - limit
    """


    def __init__(self, id=None, limit=None,):
        self.id = id
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsByAoKID_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsByAoKID_args)
RetrieveGraphsByAoKID_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveGraphsByAoKID_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype187, _size184) = iprot.readListBegin()
                    for _i188 in range(_size184):
                        _elem189 = TGraph()
                        _elem189.read(iprot)
                        self.success.append(_elem189)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsByAoKID_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter190 in self.success:
                iter190.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsByAoKID_result)
RetrieveGraphsByAoKID_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TGraph, None], False), None, ),  # 0
)


class RetrieveGraphsByAllSubjectSpecializationOf_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsByAllSubjectSpecializationOf_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsByAllSubjectSpecializationOf_args)
RetrieveGraphsByAllSubjectSpecializationOf_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveGraphsByAllSubjectSpecializationOf_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype194, _size191) = iprot.readListBegin()
                    for _i195 in range(_size191):
                        _elem196 = TGraph()
                        _elem196.read(iprot)
                        self.success.append(_elem196)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsByAllSubjectSpecializationOf_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter197 in self.success:
                iter197.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsByAllSubjectSpecializationOf_result)
RetrieveGraphsByAllSubjectSpecializationOf_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TGraph, None], False), None, ),  # 0
)


class RetrieveGraphsByAnySubjectSpecializationOf_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsByAnySubjectSpecializationOf_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsByAnySubjectSpecializationOf_args)
RetrieveGraphsByAnySubjectSpecializationOf_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveGraphsByAnySubjectSpecializationOf_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype201, _size198) = iprot.readListBegin()
                    for _i202 in range(_size198):
                        _elem203 = TGraph()
                        _elem203.read(iprot)
                        self.success.append(_elem203)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsByAnySubjectSpecializationOf_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter204 in self.success:
                iter204.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsByAnySubjectSpecializationOf_result)
RetrieveGraphsByAnySubjectSpecializationOf_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TGraph, None], False), None, ),  # 0
)


class RetrieveGraphsByAllNameLabels_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.SET:
                    self.criteria = set()
                    (_etype208, _size205) = iprot.readSetBegin()
                    for _i209 in range(_size205):
                        _elem210 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.criteria.add(_elem210)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsByAllNameLabels_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.SET, 1)
            oprot.writeSetBegin(TType.STRING, len(self.criteria))
            for iter211 in self.criteria:
                oprot.writeString(iter211.encode('utf-8') if sys.version_info[0] == 2 else iter211)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsByAllNameLabels_args)
RetrieveGraphsByAllNameLabels_args.thrift_spec = (
    None,  # 0
    (1, TType.SET, 'criteria', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveGraphsByAllNameLabels_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype215, _size212) = iprot.readListBegin()
                    for _i216 in range(_size212):
                        _elem217 = TGraph()
                        _elem217.read(iprot)
                        self.success.append(_elem217)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsByAllNameLabels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter218 in self.success:
                iter218.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsByAllNameLabels_result)
RetrieveGraphsByAllNameLabels_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TGraph, None], False), None, ),  # 0
)


class RetrieveGraphsByAnyNameLabels_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.SET:
                    self.criteria = set()
                    (_etype222, _size219) = iprot.readSetBegin()
                    for _i223 in range(_size219):
                        _elem224 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.criteria.add(_elem224)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsByAnyNameLabels_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.SET, 1)
            oprot.writeSetBegin(TType.STRING, len(self.criteria))
            for iter225 in self.criteria:
                oprot.writeString(iter225.encode('utf-8') if sys.version_info[0] == 2 else iter225)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsByAnyNameLabels_args)
RetrieveGraphsByAnyNameLabels_args.thrift_spec = (
    None,  # 0
    (1, TType.SET, 'criteria', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveGraphsByAnyNameLabels_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype229, _size226) = iprot.readListBegin()
                    for _i230 in range(_size226):
                        _elem231 = TGraph()
                        _elem231.read(iprot)
                        self.success.append(_elem231)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsByAnyNameLabels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter232 in self.success:
                iter232.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsByAnyNameLabels_result)
RetrieveGraphsByAnyNameLabels_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TGraph, None], False), None, ),  # 0
)


class RetrieveGraphsByTypes_args(object):
    """
    Attributes:
     - types
     - limit
    """


    def __init__(self, types=None, limit=None,):
        self.types = types
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.SET:
                    self.types = set()
                    (_etype236, _size233) = iprot.readSetBegin()
                    for _i237 in range(_size233):
                        _elem238 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.types.add(_elem238)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsByTypes_args')
        if self.types is not None:
            oprot.writeFieldBegin('types', TType.SET, 1)
            oprot.writeSetBegin(TType.STRING, len(self.types))
            for iter239 in self.types:
                oprot.writeString(iter239.encode('utf-8') if sys.version_info[0] == 2 else iter239)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsByTypes_args)
RetrieveGraphsByTypes_args.thrift_spec = (
    None,  # 0
    (1, TType.SET, 'types', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveGraphsByTypes_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype243, _size240) = iprot.readListBegin()
                    for _i244 in range(_size240):
                        _elem245 = TGraph()
                        _elem245.read(iprot)
                        self.success.append(_elem245)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsByTypes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter246 in self.success:
                iter246.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsByTypes_result)
RetrieveGraphsByTypes_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TGraph, None], False), None, ),  # 0
)


class RetrieveGraphsByTypeAndName_args(object):
    """
    Attributes:
     - type
     - name
     - limit
    """


    def __init__(self, type=None, name=None, limit=None,):
        self.type = type
        self.name = name
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.type = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsByTypeAndName_args')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRING, 1)
            oprot.writeString(self.type.encode('utf-8') if sys.version_info[0] == 2 else self.type)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 3)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsByTypeAndName_args)
RetrieveGraphsByTypeAndName_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'type', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'limit', None, None, ),  # 3
)


class RetrieveGraphsByTypeAndName_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype250, _size247) = iprot.readListBegin()
                    for _i251 in range(_size247):
                        _elem252 = TGraph()
                        _elem252.read(iprot)
                        self.success.append(_elem252)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsByTypeAndName_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter253 in self.success:
                iter253.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsByTypeAndName_result)
RetrieveGraphsByTypeAndName_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TGraph, None], False), None, ),  # 0
)


class GetGraphByTypeAndSpecialization_args(object):
    """
    Attributes:
     - type
     - specialization_criteria
     - limit
    """


    def __init__(self, type=None, specialization_criteria=None, limit=None,):
        self.type = type
        self.specialization_criteria = specialization_criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.type = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.specialization_criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGraphByTypeAndSpecialization_args')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRING, 1)
            oprot.writeString(self.type.encode('utf-8') if sys.version_info[0] == 2 else self.type)
            oprot.writeFieldEnd()
        if self.specialization_criteria is not None:
            oprot.writeFieldBegin('specialization_criteria', TType.STRING, 2)
            oprot.writeString(self.specialization_criteria.encode('utf-8') if sys.version_info[0] == 2 else self.specialization_criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 3)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetGraphByTypeAndSpecialization_args)
GetGraphByTypeAndSpecialization_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'type', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'specialization_criteria', 'UTF8', None, ),  # 2
    (3, TType.I32, 'limit', None, None, ),  # 3
)


class GetGraphByTypeAndSpecialization_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype257, _size254) = iprot.readListBegin()
                    for _i258 in range(_size254):
                        _elem259 = TGraph()
                        _elem259.read(iprot)
                        self.success.append(_elem259)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetGraphByTypeAndSpecialization_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter260 in self.success:
                iter260.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetGraphByTypeAndSpecialization_result)
GetGraphByTypeAndSpecialization_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TGraph, None], False), None, ),  # 0
)


class RetrieveGraphsCreatedByNiHA_args(object):
    """
    Attributes:
     - limit
    """


    def __init__(self, limit=None,):
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsCreatedByNiHA_args')
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 1)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsCreatedByNiHA_args)
RetrieveGraphsCreatedByNiHA_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'limit', None, None, ),  # 1
)


class RetrieveGraphsCreatedByNiHA_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype264, _size261) = iprot.readListBegin()
                    for _i265 in range(_size261):
                        _elem266 = TGraph()
                        _elem266.read(iprot)
                        self.success.append(_elem266)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsCreatedByNiHA_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter267 in self.success:
                iter267.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsCreatedByNiHA_result)
RetrieveGraphsCreatedByNiHA_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TGraph, None], False), None, ),  # 0
)


class RetrieveGraphsCreatedByNiHAWithUser_args(object):
    """
    Attributes:
     - when_this_user_was_signedin
     - limit
    """


    def __init__(self, when_this_user_was_signedin=None, limit=None,):
        self.when_this_user_was_signedin = when_this_user_was_signedin
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.when_this_user_was_signedin = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsCreatedByNiHAWithUser_args')
        if self.when_this_user_was_signedin is not None:
            oprot.writeFieldBegin('when_this_user_was_signedin', TType.STRING, 1)
            oprot.writeString(self.when_this_user_was_signedin.encode('utf-8') if sys.version_info[0] == 2 else self.when_this_user_was_signedin)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsCreatedByNiHAWithUser_args)
RetrieveGraphsCreatedByNiHAWithUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'when_this_user_was_signedin', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveGraphsCreatedByNiHAWithUser_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype271, _size268) = iprot.readListBegin()
                    for _i272 in range(_size268):
                        _elem273 = TGraph()
                        _elem273.read(iprot)
                        self.success.append(_elem273)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsCreatedByNiHAWithUser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter274 in self.success:
                iter274.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsCreatedByNiHAWithUser_result)
RetrieveGraphsCreatedByNiHAWithUser_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TGraph, None], False), None, ),  # 0
)


class RetrieveGraphsCreatedByNiHAWithCriteria_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsCreatedByNiHAWithCriteria_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsCreatedByNiHAWithCriteria_args)
RetrieveGraphsCreatedByNiHAWithCriteria_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveGraphsCreatedByNiHAWithCriteria_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype278, _size275) = iprot.readListBegin()
                    for _i279 in range(_size275):
                        _elem280 = TGraph()
                        _elem280.read(iprot)
                        self.success.append(_elem280)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveGraphsCreatedByNiHAWithCriteria_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter281 in self.success:
                iter281.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveGraphsCreatedByNiHAWithCriteria_result)
RetrieveGraphsCreatedByNiHAWithCriteria_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TGraph, None], False), None, ),  # 0
)


class RetriveGraphsUniqueListOfAllSubjectSpecializationLabels_args(object):
    """
    Attributes:
     - limit
    """


    def __init__(self, limit=None,):
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetriveGraphsUniqueListOfAllSubjectSpecializationLabels_args')
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 1)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetriveGraphsUniqueListOfAllSubjectSpecializationLabels_args)
RetriveGraphsUniqueListOfAllSubjectSpecializationLabels_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'limit', None, None, ),  # 1
)


class RetriveGraphsUniqueListOfAllSubjectSpecializationLabels_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype285, _size282) = iprot.readListBegin()
                    for _i286 in range(_size282):
                        _elem287 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem287)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetriveGraphsUniqueListOfAllSubjectSpecializationLabels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter288 in self.success:
                oprot.writeString(iter288.encode('utf-8') if sys.version_info[0] == 2 else iter288)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetriveGraphsUniqueListOfAllSubjectSpecializationLabels_result)
RetriveGraphsUniqueListOfAllSubjectSpecializationLabels_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class CreateRelation_args(object):
    """
    Attributes:
     - relations
    """


    def __init__(self, relations=None,):
        self.relations = relations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.relations = TRelation()
                    self.relations.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateRelation_args')
        if self.relations is not None:
            oprot.writeFieldBegin('relations', TType.STRUCT, 1)
            self.relations.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateRelation_args)
CreateRelation_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'relations', [TRelation, None], None, ),  # 1
)


class CreateRelation_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype290, _vtype291, _size289) = iprot.readMapBegin()
                    for _i293 in range(_size289):
                        _key294 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val295 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key294] = _val295
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateRelation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter296, viter297 in self.success.items():
                oprot.writeString(kiter296.encode('utf-8') if sys.version_info[0] == 2 else kiter296)
                oprot.writeString(viter297.encode('utf-8') if sys.version_info[0] == 2 else viter297)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateRelation_result)
CreateRelation_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
)


class CreateRelationWithNodes_args(object):
    """
    Attributes:
     - source_node
     - target_node
    """


    def __init__(self, source_node=None, target_node=None,):
        self.source_node = source_node
        self.target_node = target_node

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.source_node = TNode()
                    self.source_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.target_node = TNode()
                    self.target_node.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateRelationWithNodes_args')
        if self.source_node is not None:
            oprot.writeFieldBegin('source_node', TType.STRUCT, 1)
            self.source_node.write(oprot)
            oprot.writeFieldEnd()
        if self.target_node is not None:
            oprot.writeFieldBegin('target_node', TType.STRUCT, 2)
            self.target_node.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateRelationWithNodes_args)
CreateRelationWithNodes_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'source_node', [TNode, None], None, ),  # 1
    (2, TType.STRUCT, 'target_node', [TNode, None], None, ),  # 2
)


class CreateRelationWithNodes_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateRelationWithNodes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateRelationWithNodes_result)
CreateRelationWithNodes_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class UpdateRelation_args(object):
    """
    Attributes:
     - relation
    """


    def __init__(self, relation=None,):
        self.relation = relation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.relation = TRelation()
                    self.relation.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UpdateRelation_args')
        if self.relation is not None:
            oprot.writeFieldBegin('relation', TType.STRUCT, 1)
            self.relation.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(UpdateRelation_args)
UpdateRelation_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'relation', [TRelation, None], None, ),  # 1
)


class UpdateRelation_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UpdateRelation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(UpdateRelation_result)
UpdateRelation_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class DeleteRelation_args(object):
    """
    Attributes:
     - criteria
    """


    def __init__(self, criteria=None,):
        self.criteria = criteria

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteRelation_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DeleteRelation_args)
DeleteRelation_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
)


class DeleteRelation_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteRelation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DeleteRelation_result)
DeleteRelation_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class RetrieveRelationByNeo4jId_args(object):
    """
    Attributes:
     - id
     - limit
    """


    def __init__(self, id=None, limit=None,):
        self.id = id
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationByNeo4jId_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationByNeo4jId_args)
RetrieveRelationByNeo4jId_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveRelationByNeo4jId_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TRelation()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationByNeo4jId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationByNeo4jId_result)
RetrieveRelationByNeo4jId_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TRelation, None], None, ),  # 0
)


class RetrieveRelations_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelations_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelations_args)
RetrieveRelations_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveRelations_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype301, _size298) = iprot.readListBegin()
                    for _i302 in range(_size298):
                        _elem303 = TRelation()
                        _elem303.read(iprot)
                        self.success.append(_elem303)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelations_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter304 in self.success:
                iter304.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelations_result)
RetrieveRelations_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TRelation, None], False), None, ),  # 0
)


class RetrieveRelationsByGraphID_args(object):
    """
    Attributes:
     - graphid
     - limit
    """


    def __init__(self, graphid=None, limit=None,):
        self.graphid = graphid
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.graphid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsByGraphID_args')
        if self.graphid is not None:
            oprot.writeFieldBegin('graphid', TType.STRING, 1)
            oprot.writeString(self.graphid.encode('utf-8') if sys.version_info[0] == 2 else self.graphid)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsByGraphID_args)
RetrieveRelationsByGraphID_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'graphid', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveRelationsByGraphID_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype308, _size305) = iprot.readListBegin()
                    for _i309 in range(_size305):
                        _elem310 = TRelation()
                        _elem310.read(iprot)
                        self.success.append(_elem310)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsByGraphID_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter311 in self.success:
                iter311.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsByGraphID_result)
RetrieveRelationsByGraphID_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TRelation, None], False), None, ),  # 0
)


class RetrieveRelationsByAoKID_args(object):
    """
    Attributes:
     - id
     - limit
    """


    def __init__(self, id=None, limit=None,):
        self.id = id
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsByAoKID_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsByAoKID_args)
RetrieveRelationsByAoKID_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveRelationsByAoKID_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype315, _size312) = iprot.readListBegin()
                    for _i316 in range(_size312):
                        _elem317 = TRelation()
                        _elem317.read(iprot)
                        self.success.append(_elem317)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsByAoKID_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter318 in self.success:
                iter318.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsByAoKID_result)
RetrieveRelationsByAoKID_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TRelation, None], False), None, ),  # 0
)


class RetrieveRelationsBySpecializationOf_args(object):
    """
    Attributes:
     - subject_specialization
     - limit
    """


    def __init__(self, subject_specialization=None, limit=None,):
        self.subject_specialization = subject_specialization
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.subject_specialization = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsBySpecializationOf_args')
        if self.subject_specialization is not None:
            oprot.writeFieldBegin('subject_specialization', TType.STRING, 1)
            oprot.writeString(self.subject_specialization.encode('utf-8') if sys.version_info[0] == 2 else self.subject_specialization)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsBySpecializationOf_args)
RetrieveRelationsBySpecializationOf_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'subject_specialization', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveRelationsBySpecializationOf_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype322, _size319) = iprot.readListBegin()
                    for _i323 in range(_size319):
                        _elem324 = TRelation()
                        _elem324.read(iprot)
                        self.success.append(_elem324)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsBySpecializationOf_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter325 in self.success:
                iter325.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsBySpecializationOf_result)
RetrieveRelationsBySpecializationOf_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TRelation, None], False), None, ),  # 0
)


class RetrieveRelationsNameLabels_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsNameLabels_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsNameLabels_args)
RetrieveRelationsNameLabels_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveRelationsNameLabels_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype329, _size326) = iprot.readListBegin()
                    for _i330 in range(_size326):
                        _elem331 = TRelation()
                        _elem331.read(iprot)
                        self.success.append(_elem331)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsNameLabels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter332 in self.success:
                iter332.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsNameLabels_result)
RetrieveRelationsNameLabels_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TRelation, None], False), None, ),  # 0
)


class RetrieveRelationsTruthValue_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsTruthValue_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsTruthValue_args)
RetrieveRelationsTruthValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveRelationsTruthValue_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype336, _size333) = iprot.readListBegin()
                    for _i337 in range(_size333):
                        _elem338 = TRelation()
                        _elem338.read(iprot)
                        self.success.append(_elem338)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsTruthValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter339 in self.success:
                iter339.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsTruthValue_result)
RetrieveRelationsTruthValue_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TRelation, None], False), None, ),  # 0
)


class RetrieveRelationsByDateTime_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsByDateTime_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsByDateTime_args)
RetrieveRelationsByDateTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveRelationsByDateTime_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype343, _size340) = iprot.readListBegin()
                    for _i344 in range(_size340):
                        _elem345 = TRelation()
                        _elem345.read(iprot)
                        self.success.append(_elem345)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsByDateTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter346 in self.success:
                iter346.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsByDateTime_result)
RetrieveRelationsByDateTime_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TRelation, None], False), None, ),  # 0
)


class RetrieveRelationsByAge_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsByAge_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsByAge_args)
RetrieveRelationsByAge_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveRelationsByAge_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype350, _size347) = iprot.readListBegin()
                    for _i351 in range(_size347):
                        _elem352 = TRelation()
                        _elem352.read(iprot)
                        self.success.append(_elem352)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsByAge_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter353 in self.success:
                iter353.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsByAge_result)
RetrieveRelationsByAge_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TRelation, None], False), None, ),  # 0
)


class RetrieveRelationsAttentionLevel_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsAttentionLevel_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsAttentionLevel_args)
RetrieveRelationsAttentionLevel_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveRelationsAttentionLevel_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype357, _size354) = iprot.readListBegin()
                    for _i358 in range(_size354):
                        _elem359 = TRelation()
                        _elem359.read(iprot)
                        self.success.append(_elem359)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsAttentionLevel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter360 in self.success:
                iter360.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsAttentionLevel_result)
RetrieveRelationsAttentionLevel_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TRelation, None], False), None, ),  # 0
)


class RetrieveRelationsScratchPad_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsScratchPad_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsScratchPad_args)
RetrieveRelationsScratchPad_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveRelationsScratchPad_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype364, _size361) = iprot.readListBegin()
                    for _i365 in range(_size361):
                        _elem366 = TRelation()
                        _elem366.read(iprot)
                        self.success.append(_elem366)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsScratchPad_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter367 in self.success:
                iter367.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsScratchPad_result)
RetrieveRelationsScratchPad_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TRelation, None], False), None, ),  # 0
)


class RetrieveRelationsByUser_args(object):
    """
    Attributes:
     - userid
     - limit
    """


    def __init__(self, userid=None, limit=None,):
        self.userid = userid
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsByUser_args')
        if self.userid is not None:
            oprot.writeFieldBegin('userid', TType.STRING, 1)
            oprot.writeString(self.userid.encode('utf-8') if sys.version_info[0] == 2 else self.userid)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsByUser_args)
RetrieveRelationsByUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userid', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveRelationsByUser_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype371, _size368) = iprot.readListBegin()
                    for _i372 in range(_size368):
                        _elem373 = TRelation()
                        _elem373.read(iprot)
                        self.success.append(_elem373)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsByUser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter374 in self.success:
                iter374.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsByUser_result)
RetrieveRelationsByUser_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TRelation, None], False), None, ),  # 0
)


class RetrieveRelationsCreateByUser_args(object):
    """
    Attributes:
     - userid
     - limit
    """


    def __init__(self, userid=None, limit=None,):
        self.userid = userid
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsCreateByUser_args')
        if self.userid is not None:
            oprot.writeFieldBegin('userid', TType.STRING, 1)
            oprot.writeString(self.userid.encode('utf-8') if sys.version_info[0] == 2 else self.userid)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsCreateByUser_args)
RetrieveRelationsCreateByUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userid', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveRelationsCreateByUser_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype378, _size375) = iprot.readListBegin()
                    for _i379 in range(_size375):
                        _elem380 = TRelation()
                        _elem380.read(iprot)
                        self.success.append(_elem380)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsCreateByUser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter381 in self.success:
                iter381.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsCreateByUser_result)
RetrieveRelationsCreateByUser_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TRelation, None], False), None, ),  # 0
)


class RetrieveRelationsCreatedByNiHA_args(object):
    """
    Attributes:
     - limit
    """


    def __init__(self, limit=None,):
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsCreatedByNiHA_args')
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 1)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsCreatedByNiHA_args)
RetrieveRelationsCreatedByNiHA_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'limit', None, None, ),  # 1
)


class RetrieveRelationsCreatedByNiHA_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype385, _size382) = iprot.readListBegin()
                    for _i386 in range(_size382):
                        _elem387 = TRelation()
                        _elem387.read(iprot)
                        self.success.append(_elem387)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsCreatedByNiHA_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter388 in self.success:
                iter388.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsCreatedByNiHA_result)
RetrieveRelationsCreatedByNiHA_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TRelation, None], False), None, ),  # 0
)


class RetrieveRelationsCreatedByNiHAWithUser_args(object):
    """
    Attributes:
     - when_this_user_was_signedin
     - limit
    """


    def __init__(self, when_this_user_was_signedin=None, limit=None,):
        self.when_this_user_was_signedin = when_this_user_was_signedin
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.when_this_user_was_signedin = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsCreatedByNiHAWithUser_args')
        if self.when_this_user_was_signedin is not None:
            oprot.writeFieldBegin('when_this_user_was_signedin', TType.STRING, 1)
            oprot.writeString(self.when_this_user_was_signedin.encode('utf-8') if sys.version_info[0] == 2 else self.when_this_user_was_signedin)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsCreatedByNiHAWithUser_args)
RetrieveRelationsCreatedByNiHAWithUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'when_this_user_was_signedin', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveRelationsCreatedByNiHAWithUser_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype392, _size389) = iprot.readListBegin()
                    for _i393 in range(_size389):
                        _elem394 = TRelation()
                        _elem394.read(iprot)
                        self.success.append(_elem394)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsCreatedByNiHAWithUser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter395 in self.success:
                iter395.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsCreatedByNiHAWithUser_result)
RetrieveRelationsCreatedByNiHAWithUser_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TRelation, None], False), None, ),  # 0
)


class RetrieveRelationsCreatedByNiHAWithCriteria_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsCreatedByNiHAWithCriteria_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsCreatedByNiHAWithCriteria_args)
RetrieveRelationsCreatedByNiHAWithCriteria_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveRelationsCreatedByNiHAWithCriteria_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype399, _size396) = iprot.readListBegin()
                    for _i400 in range(_size396):
                        _elem401 = TRelation()
                        _elem401.read(iprot)
                        self.success.append(_elem401)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsCreatedByNiHAWithCriteria_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter402 in self.success:
                iter402.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsCreatedByNiHAWithCriteria_result)
RetrieveRelationsCreatedByNiHAWithCriteria_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TRelation, None], False), None, ),  # 0
)


class RetrieveRelationsUniqueListOfAllSpecializationLabels_args(object):
    """
    Attributes:
     - limit
    """


    def __init__(self, limit=None,):
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsUniqueListOfAllSpecializationLabels_args')
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 1)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsUniqueListOfAllSpecializationLabels_args)
RetrieveRelationsUniqueListOfAllSpecializationLabels_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'limit', None, None, ),  # 1
)


class RetrieveRelationsUniqueListOfAllSpecializationLabels_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype406, _size403) = iprot.readListBegin()
                    for _i407 in range(_size403):
                        _elem408 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem408)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveRelationsUniqueListOfAllSpecializationLabels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter409 in self.success:
                oprot.writeString(iter409.encode('utf-8') if sys.version_info[0] == 2 else iter409)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveRelationsUniqueListOfAllSpecializationLabels_result)
RetrieveRelationsUniqueListOfAllSpecializationLabels_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class CreateNodes_args(object):
    """
    Attributes:
     - node
    """


    def __init__(self, node=None,):
        self.node = node

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.node = TNode()
                    self.node.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateNodes_args')
        if self.node is not None:
            oprot.writeFieldBegin('node', TType.STRUCT, 1)
            self.node.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateNodes_args)
CreateNodes_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'node', [TNode, None], None, ),  # 1
)


class CreateNodes_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateNodes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateNodes_result)
CreateNodes_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class RetrieveByNeo4jId_args(object):
    """
    Attributes:
     - id
    """


    def __init__(self, id=None,):
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveByNeo4jId_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveByNeo4jId_args)
RetrieveByNeo4jId_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
)


class RetrieveByNeo4jId_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TNode()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveByNeo4jId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveByNeo4jId_result)
RetrieveByNeo4jId_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TNode, None], None, ),  # 0
)


class RetrieveNodes_args(object):
    """
    Attributes:
     - query
    """


    def __init__(self, query=None,):
        self.query = query

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.query = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodes_args')
        if self.query is not None:
            oprot.writeFieldBegin('query', TType.STRING, 1)
            oprot.writeString(self.query.encode('utf-8') if sys.version_info[0] == 2 else self.query)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodes_args)
RetrieveNodes_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'query', 'UTF8', None, ),  # 1
)


class RetrieveNodes_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype413, _size410) = iprot.readListBegin()
                    for _i414 in range(_size410):
                        _elem415 = TNode()
                        _elem415.read(iprot)
                        self.success.append(_elem415)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter416 in self.success:
                iter416.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodes_result)
RetrieveNodes_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNode, None], False), None, ),  # 0
)


class RetrieveNodesByGraphID_args(object):
    """
    Attributes:
     - graphid
     - limit
    """


    def __init__(self, graphid=None, limit=None,):
        self.graphid = graphid
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.graphid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByGraphID_args')
        if self.graphid is not None:
            oprot.writeFieldBegin('graphid', TType.STRING, 1)
            oprot.writeString(self.graphid.encode('utf-8') if sys.version_info[0] == 2 else self.graphid)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByGraphID_args)
RetrieveNodesByGraphID_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'graphid', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveNodesByGraphID_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype420, _size417) = iprot.readListBegin()
                    for _i421 in range(_size417):
                        _elem422 = TNode()
                        _elem422.read(iprot)
                        self.success.append(_elem422)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByGraphID_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter423 in self.success:
                iter423.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByGraphID_result)
RetrieveNodesByGraphID_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNode, None], False), None, ),  # 0
)


class RetrieveNodesByAoKID_args(object):
    """
    Attributes:
     - id
     - limit
    """


    def __init__(self, id=None, limit=None,):
        self.id = id
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.id = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByAoKID_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.STRING, 1)
            oprot.writeString(self.id.encode('utf-8') if sys.version_info[0] == 2 else self.id)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByAoKID_args)
RetrieveNodesByAoKID_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'id', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveNodesByAoKID_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype427, _size424) = iprot.readListBegin()
                    for _i428 in range(_size424):
                        _elem429 = TNode()
                        _elem429.read(iprot)
                        self.success.append(_elem429)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByAoKID_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter430 in self.success:
                iter430.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByAoKID_result)
RetrieveNodesByAoKID_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNode, None], False), None, ),  # 0
)


class RetrieveNodesByAllSubjectSpecializationOf_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByAllSubjectSpecializationOf_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByAllSubjectSpecializationOf_args)
RetrieveNodesByAllSubjectSpecializationOf_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveNodesByAllSubjectSpecializationOf_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype434, _size431) = iprot.readListBegin()
                    for _i435 in range(_size431):
                        _elem436 = TNode()
                        _elem436.read(iprot)
                        self.success.append(_elem436)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByAllSubjectSpecializationOf_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter437 in self.success:
                iter437.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByAllSubjectSpecializationOf_result)
RetrieveNodesByAllSubjectSpecializationOf_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNode, None], False), None, ),  # 0
)


class RetrieveNodesByAnySubjectSpecializationOf_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByAnySubjectSpecializationOf_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByAnySubjectSpecializationOf_args)
RetrieveNodesByAnySubjectSpecializationOf_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveNodesByAnySubjectSpecializationOf_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype441, _size438) = iprot.readListBegin()
                    for _i442 in range(_size438):
                        _elem443 = TNode()
                        _elem443.read(iprot)
                        self.success.append(_elem443)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByAnySubjectSpecializationOf_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter444 in self.success:
                iter444.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByAnySubjectSpecializationOf_result)
RetrieveNodesByAnySubjectSpecializationOf_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNode, None], False), None, ),  # 0
)


class RetrieveNodesByAnyNameLabels_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByAnyNameLabels_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByAnyNameLabels_args)
RetrieveNodesByAnyNameLabels_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveNodesByAnyNameLabels_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype448, _size445) = iprot.readListBegin()
                    for _i449 in range(_size445):
                        _elem450 = TNode()
                        _elem450.read(iprot)
                        self.success.append(_elem450)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByAnyNameLabels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter451 in self.success:
                iter451.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByAnyNameLabels_result)
RetrieveNodesByAnyNameLabels_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNode, None], False), None, ),  # 0
)


class RetrieveNodesByAllNameLabels_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByAllNameLabels_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByAllNameLabels_args)
RetrieveNodesByAllNameLabels_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveNodesByAllNameLabels_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype455, _size452) = iprot.readListBegin()
                    for _i456 in range(_size452):
                        _elem457 = TNode()
                        _elem457.read(iprot)
                        self.success.append(_elem457)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByAllNameLabels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter458 in self.success:
                iter458.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByAllNameLabels_result)
RetrieveNodesByAllNameLabels_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNode, None], False), None, ),  # 0
)


class RetrieveNodesTruthValue_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesTruthValue_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesTruthValue_args)
RetrieveNodesTruthValue_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveNodesTruthValue_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype462, _size459) = iprot.readListBegin()
                    for _i463 in range(_size459):
                        _elem464 = TNode()
                        _elem464.read(iprot)
                        self.success.append(_elem464)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesTruthValue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter465 in self.success:
                iter465.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesTruthValue_result)
RetrieveNodesTruthValue_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNode, None], False), None, ),  # 0
)


class RetrieveNodesByEvaluation_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByEvaluation_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByEvaluation_args)
RetrieveNodesByEvaluation_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveNodesByEvaluation_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype469, _size466) = iprot.readListBegin()
                    for _i470 in range(_size466):
                        _elem471 = TNode()
                        _elem471.read(iprot)
                        self.success.append(_elem471)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByEvaluation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter472 in self.success:
                iter472.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByEvaluation_result)
RetrieveNodesByEvaluation_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNode, None], False), None, ),  # 0
)


class RetrieveNodesByDateTime_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByDateTime_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByDateTime_args)
RetrieveNodesByDateTime_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveNodesByDateTime_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype476, _size473) = iprot.readListBegin()
                    for _i477 in range(_size473):
                        _elem478 = TNode()
                        _elem478.read(iprot)
                        self.success.append(_elem478)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByDateTime_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter479 in self.success:
                iter479.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByDateTime_result)
RetrieveNodesByDateTime_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNode, None], False), None, ),  # 0
)


class RetrieveNodesByAge_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByAge_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByAge_args)
RetrieveNodesByAge_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveNodesByAge_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype483, _size480) = iprot.readListBegin()
                    for _i484 in range(_size480):
                        _elem485 = TNode()
                        _elem485.read(iprot)
                        self.success.append(_elem485)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByAge_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter486 in self.success:
                iter486.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByAge_result)
RetrieveNodesByAge_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNode, None], False), None, ),  # 0
)


class RetrieveNodesAttentionLevel_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesAttentionLevel_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesAttentionLevel_args)
RetrieveNodesAttentionLevel_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveNodesAttentionLevel_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype490, _size487) = iprot.readListBegin()
                    for _i491 in range(_size487):
                        _elem492 = TNode()
                        _elem492.read(iprot)
                        self.success.append(_elem492)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesAttentionLevel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter493 in self.success:
                iter493.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesAttentionLevel_result)
RetrieveNodesAttentionLevel_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNode, None], False), None, ),  # 0
)


class RetrieveNodesByScratchPad_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByScratchPad_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByScratchPad_args)
RetrieveNodesByScratchPad_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveNodesByScratchPad_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype497, _size494) = iprot.readListBegin()
                    for _i498 in range(_size494):
                        _elem499 = TNode()
                        _elem499.read(iprot)
                        self.success.append(_elem499)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByScratchPad_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter500 in self.success:
                iter500.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByScratchPad_result)
RetrieveNodesByScratchPad_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNode, None], False), None, ),  # 0
)


class RetrieveNodesByUser_args(object):
    """
    Attributes:
     - userid
     - limit
    """


    def __init__(self, userid=None, limit=None,):
        self.userid = userid
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByUser_args')
        if self.userid is not None:
            oprot.writeFieldBegin('userid', TType.STRING, 1)
            oprot.writeString(self.userid.encode('utf-8') if sys.version_info[0] == 2 else self.userid)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByUser_args)
RetrieveNodesByUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userid', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveNodesByUser_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype504, _size501) = iprot.readListBegin()
                    for _i505 in range(_size501):
                        _elem506 = TNode()
                        _elem506.read(iprot)
                        self.success.append(_elem506)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesByUser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter507 in self.success:
                iter507.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesByUser_result)
RetrieveNodesByUser_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNode, None], False), None, ),  # 0
)


class RetrieveNodesCreateByUser_args(object):
    """
    Attributes:
     - userid
     - limit
    """


    def __init__(self, userid=None, limit=None,):
        self.userid = userid
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesCreateByUser_args')
        if self.userid is not None:
            oprot.writeFieldBegin('userid', TType.STRING, 1)
            oprot.writeString(self.userid.encode('utf-8') if sys.version_info[0] == 2 else self.userid)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesCreateByUser_args)
RetrieveNodesCreateByUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userid', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveNodesCreateByUser_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype511, _size508) = iprot.readListBegin()
                    for _i512 in range(_size508):
                        _elem513 = TNode()
                        _elem513.read(iprot)
                        self.success.append(_elem513)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesCreateByUser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter514 in self.success:
                iter514.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesCreateByUser_result)
RetrieveNodesCreateByUser_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNode, None], False), None, ),  # 0
)


class RetrieveNodesCreatedByNiHA_args(object):
    """
    Attributes:
     - limit
    """


    def __init__(self, limit=None,):
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesCreatedByNiHA_args')
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 1)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesCreatedByNiHA_args)
RetrieveNodesCreatedByNiHA_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'limit', None, None, ),  # 1
)


class RetrieveNodesCreatedByNiHA_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype518, _size515) = iprot.readListBegin()
                    for _i519 in range(_size515):
                        _elem520 = TNode()
                        _elem520.read(iprot)
                        self.success.append(_elem520)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesCreatedByNiHA_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter521 in self.success:
                iter521.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesCreatedByNiHA_result)
RetrieveNodesCreatedByNiHA_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNode, None], False), None, ),  # 0
)


class RetrieveNodesCreatedByNiHAWithUser_args(object):
    """
    Attributes:
     - when_this_user_was_signedin
     - limit
    """


    def __init__(self, when_this_user_was_signedin=None, limit=None,):
        self.when_this_user_was_signedin = when_this_user_was_signedin
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.when_this_user_was_signedin = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesCreatedByNiHAWithUser_args')
        if self.when_this_user_was_signedin is not None:
            oprot.writeFieldBegin('when_this_user_was_signedin', TType.STRING, 1)
            oprot.writeString(self.when_this_user_was_signedin.encode('utf-8') if sys.version_info[0] == 2 else self.when_this_user_was_signedin)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesCreatedByNiHAWithUser_args)
RetrieveNodesCreatedByNiHAWithUser_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'when_this_user_was_signedin', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveNodesCreatedByNiHAWithUser_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype525, _size522) = iprot.readListBegin()
                    for _i526 in range(_size522):
                        _elem527 = TNode()
                        _elem527.read(iprot)
                        self.success.append(_elem527)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesCreatedByNiHAWithUser_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter528 in self.success:
                iter528.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesCreatedByNiHAWithUser_result)
RetrieveNodesCreatedByNiHAWithUser_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNode, None], False), None, ),  # 0
)


class RetrieveNodesCreatedByNiHAWithCriteria_args(object):
    """
    Attributes:
     - criteria
     - limit
    """


    def __init__(self, criteria=None, limit=None,):
        self.criteria = criteria
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesCreatedByNiHAWithCriteria_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 2)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesCreatedByNiHAWithCriteria_args)
RetrieveNodesCreatedByNiHAWithCriteria_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
    (2, TType.I32, 'limit', None, None, ),  # 2
)


class RetrieveNodesCreatedByNiHAWithCriteria_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype532, _size529) = iprot.readListBegin()
                    for _i533 in range(_size529):
                        _elem534 = TNode()
                        _elem534.read(iprot)
                        self.success.append(_elem534)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetrieveNodesCreatedByNiHAWithCriteria_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter535 in self.success:
                iter535.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetrieveNodesCreatedByNiHAWithCriteria_result)
RetrieveNodesCreatedByNiHAWithCriteria_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TNode, None], False), None, ),  # 0
)


class RetriveNodesUniqueListOfAllSpecializationLabels_args(object):
    """
    Attributes:
     - limit
    """


    def __init__(self, limit=None,):
        self.limit = limit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetriveNodesUniqueListOfAllSpecializationLabels_args')
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 1)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetriveNodesUniqueListOfAllSpecializationLabels_args)
RetriveNodesUniqueListOfAllSpecializationLabels_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'limit', None, None, ),  # 1
)


class RetriveNodesUniqueListOfAllSpecializationLabels_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype539, _size536) = iprot.readListBegin()
                    for _i540 in range(_size536):
                        _elem541 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem541)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RetriveNodesUniqueListOfAllSpecializationLabels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter542 in self.success:
                oprot.writeString(iter542.encode('utf-8') if sys.version_info[0] == 2 else iter542)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RetriveNodesUniqueListOfAllSpecializationLabels_result)
RetriveNodesUniqueListOfAllSpecializationLabels_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class UpdateNode_args(object):
    """
    Attributes:
     - node
    """


    def __init__(self, node=None,):
        self.node = node

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.node = TNode()
                    self.node.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UpdateNode_args')
        if self.node is not None:
            oprot.writeFieldBegin('node', TType.STRUCT, 1)
            self.node.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(UpdateNode_args)
UpdateNode_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'node', [TNode, None], None, ),  # 1
)


class UpdateNode_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UpdateNode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(UpdateNode_result)
UpdateNode_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class DeleteNode_args(object):
    """
    Attributes:
     - criteria
    """


    def __init__(self, criteria=None,):
        self.criteria = criteria

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.criteria = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteNode_args')
        if self.criteria is not None:
            oprot.writeFieldBegin('criteria', TType.STRING, 1)
            oprot.writeString(self.criteria.encode('utf-8') if sys.version_info[0] == 2 else self.criteria)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DeleteNode_args)
DeleteNode_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'criteria', 'UTF8', None, ),  # 1
)


class DeleteNode_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DeleteNode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DeleteNode_result)
DeleteNode_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)
fix_spec(all_structs)
del all_structs

